/*************************************************************************/ /*!
@File           khronos_egl.h
@Title          Main imgegl implementation
@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
@Description    Main imgegl implementation
@License        Strictly Confidential.
*/ /**************************************************************************/

#include <string.h>
#include "egl_internal.h"
#include "drvegl.h"
#include "drveglext.h"
#include "wsegl.h"
#include "math.h"
#include "cfg.h"
#include "tls.h"
#include "qsort.h"
#include "srv.h"
#include "generic_ws.h"
#include "function_table.h"
#include "imgegl_int.h"

#if defined(EGL_EXTENSION_KHR_IMAGE)
#   include "egl_eglimage.h"
#endif /* defined(EGL_EXTENSION_KHR_IMAGE) */

#if defined(EGL_EXTENSION_KHR_FENCE_SYNC) || defined(EGL_EXTENSION_KHR_REUSABLE_SYNC)
#   include "egl_sync.h"
#endif /* defined(EGL_EXTENSION_KHR_FENCE_SYNC) || defined(EGL_EXTENSION_KHR_REUSABLE_SYNC) */

#if defined(EGL_EXTENSION_ANDROID_BLOB_CACHE)
#include "blobcache.h"
#endif

#if defined(__linux__)
	/* Use the autogenerated file */
#   include "pvrversion.h"
#else
#   define PVRVERSION_STRING_SHORT "1"
#endif

#   define STATIC static



typedef void (IMG_CALLCONV *EGL_PROC)(IMG_VOID);


/* This function allows our PVR_ASSERT to be embedded in an expression */
#ifdef INLINE_IS_PRAGMA
#   pragma inline(_exp_assert)
#endif
static INLINE int _exp_assert(int a)
{
	PVR_ASSERT(a);
	return a;
}

#define ASSERT_EXP(a)   (_exp_assert(a))

#define _EGL_CONFIG_ATTR_FIRST      EGL_BUFFER_SIZE

#define _EGL_CONFIG_ATTR_LAST       EGL_CONFORMANT


/* Bias upwards because EGL_NO_DISPLAY is zero */
#define SLOT_INDEX_TO_EGLDISPLAY(index)	((signed int)ASSERT_EXP(EGL_NO_DISPLAY == 0),((EGLDisplay)(index+1)))

#define EGLDISPLAY_TO_SLOT_INDEX(egldisplay)            \
	(                                                   \
		(signed int)ASSERT_EXP(EGL_NO_DISPLAY == 0),    \
		(signed int)ASSERT_EXP(egldisplay != 0),        \
		((signed int)egldisplay-1)                      \
	)


/* Lookup table to save having several switch statements */
#define DEFAULT_FORMAT WSEGL_PIXELFORMAT_565
static const WSEGLPixelFormat aConvertPVRPixelFormatToWSEGL[] =
{
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_UNKNOWN*/
	WSEGL_PIXELFORMAT_565,      /*PVRSRV_PIXEL_FORMAT_RGB565*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_RGB555*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_RGB888*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_BGR888*/
	DEFAULT_FORMAT,             /*Unused*/
	DEFAULT_FORMAT,             /*Unused*/
	DEFAULT_FORMAT,             /*Unused*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_GREY_SCALE*/
	DEFAULT_FORMAT,             /*Unused*/
	DEFAULT_FORMAT,             /*Unused*/
	DEFAULT_FORMAT,             /*Unused*/
	DEFAULT_FORMAT,             /*Unused*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_PAL12*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_PAL8*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_PAL4*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_PAL2*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_PAL1*/
	WSEGL_PIXELFORMAT_1555,     /*PVRSRV_PIXEL_FORMAT_ARGB1555*/
	WSEGL_PIXELFORMAT_4444,     /*PVRSRV_PIXEL_FORMAT_ARGB4444*/
	WSEGL_PIXELFORMAT_ARGB8888, /*PVRSRV_PIXEL_FORMAT_ARGB8888*/
	WSEGL_PIXELFORMAT_ABGR8888, /*PVRSRV_PIXEL_FORMAT_ABGR8888*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_YV12*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_I420*/
	DEFAULT_FORMAT,             /*Unused*/
	DEFAULT_FORMAT,             /*PVRSRV_PIXEL_FORMAT_IMC2*/
	WSEGL_PIXELFORMAT_XRGB8888, /*PVRSRV_PIXEL_FORMAT_XRGB8888*/
	WSEGL_PIXELFORMAT_XBGR8888  /*PVRSRV_PIXEL_FORMAT_XBGR8888*/
};

IMG_INTERNAL const IMG_UINT32 aWSEGLPixelFormatBytesPerPixelShift[] =
{
	1,	/*WSEGL_PIXELFORMAT_565      - 2 bytes, shift by 1*/
	1,	/*WSEGL_PIXELFORMAT_4444     - 2 bytes, shift by 1*/
	2,	/*WSEGL_PIXELFORMAT_ARGB8888 - 4 bytes, shift by 2*/
	1,	/*WSEGL_PIXELFORMAT_1555     - 2 bytes, shift by 1*/
	2,	/*WSEGL_PIXELFORMAT_ABGR8888 - 4 bytes, shift by 2*/
	2,	/*WSEGL_PIXELFORMAT_XBGR8888 - 4 bytes, shift by 2*/
	0,  /*WSEGL_PIXELFORMAT_NV12     - 1 byte,  shift by 0*/
	1,  /*WSEGL_PIXELFORMAT_YUYV     - 2 bytes, shift by 1*/
	0,  /*WSEGL_PIXELFORMAT_YV12     - 1 byte,  shift by 0*/
	2,	/*WSEGL_PIXELFORMAT_XRGB8888 - 4 bytes, shift by 2*/
	1,  /*WSEGL_PIXELFORMAT_UYVY     - 2 bytes, shift by 1*/
};


#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
IMG_INTERNAL EGLBoolean IMGeglHibernateProcessIMG(void);
IMG_INTERNAL EGLBoolean IMGeglAwakenProcessIMG(void);
#endif

IMG_INTERNAL IMG_VOID EGLThreadLock(TLS psTls)
{
	PVRSRVLockMutex(psTls->psGlobalData->hEGLGlobalResource);
}

IMG_INTERNAL IMG_VOID EGLThreadUnlock(TLS psTls)
{
	PVRSRVUnlockMutex(psTls->psGlobalData->hEGLGlobalResource);
}

/***********************************************************************
 *
 *  FUNCTION   : GlobalDataDeinit
 *  PURPOSE    : Global data deinitialisation callback
 *  PARAMETERS : Pointer to global data
 *  RETURNS    : None
 *
 ***********************************************************************/
static IMG_VOID GlobalDataDeinit(IMG_VOID *pvGlobalData)
{
	EGLGlobal *psGlobalData = (EGLGlobal *)pvGlobalData;
	PVRSRV_ERROR eError;

	if (psGlobalData->hEGLGlobalResource)
	{
		eError = PVRSRVDestroyMutex(psGlobalData->hEGLGlobalResource);

		if (eError != PVRSRV_OK)
		{
			PVR_DPF((PVR_DBG_ERROR,"GlobalDataDeinit: PVRSRVDestroyMutex failed (%d)", eError));
		}
	}

	psGlobalData->hEGLGlobalResource = 0;

#if defined(DEBUG)
	if (psGlobalData->hEGLMemTrackingResource)
	{
		eError = PVRSRVDestroyMutex(psGlobalData->hEGLMemTrackingResource);

		if (eError != PVRSRV_OK)
		{
			PVR_DPF((PVR_DBG_ERROR,"GlobalDataDeinit: PVRSRVDestroyMutex failed (%d)", eError));
		}
	}

	psGlobalData->hEGLMemTrackingResource = 0;
#endif /* defined(DEBUG) */
}

/*  Module unload region  */ 
#if 1 
#if (defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)) || defined(API_MODULES_RUNTIME_CHECKED)
static void _UnloadOpenVG(EGLGlobal *psEGLGlobalData)
{
	if (psEGLGlobalData->bHaveOVGFunctions)
	{
		if (!UnloadModule(psEGLGlobalData->hOVGDrv))
		{
			PVR_DPF((PVR_DBG_WARNING, "_UnloadOpenVG: Failed to unload OVG module"));
		}

		psEGLGlobalData->bHaveOVGFunctions = IMG_FALSE;
	}
}
#endif /* (defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
static IMG_VOID _UnloadOpenGLES1(EGLGlobal *psEGLGlobalData)
{
	if (psEGLGlobalData->bHaveOGLES1Functions)
	{
		if (!UnloadModule(psEGLGlobalData->hOGLES1Drv))
		{
			PVR_DPF((PVR_DBG_WARNING, "_UnloadOpenGLES1: Failed to unload OGLES1 module"));
		}

		psEGLGlobalData->bHaveOGLES1Functions = IMG_FALSE;
	}
}
#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
static IMG_VOID _UnloadOpenGLES2(EGLGlobal *psEGLGlobalData)
{
	if (psEGLGlobalData->bHaveOGLES2Functions)
	{
		if (!UnloadModule(psEGLGlobalData->hOGLES2Drv))
		{
			PVR_DPF((PVR_DBG_WARNING, "_UnloadOpenGLES2: Failed to unload OGLES2 module"));
		}

		psEGLGlobalData->bHaveOGLES2Functions = IMG_FALSE;
	}
}
#endif  /* defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
static IMG_VOID _UnloadOpenGL(EGLGlobal *psEGLGlobalData)
{
	if (psEGLGlobalData->bHaveOGLFunctions)
	{
		if (!UnloadModule(psEGLGlobalData->hOGLDrv))
		{
			PVR_DPF((PVR_DBG_WARNING, "_UnloadOpenGL: Failed to unload OGL module"));
		}

		psEGLGlobalData->bHaveOGLFunctions = IMG_FALSE;
	}
}
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENCL) || defined(API_MODULES_RUNTIME_CHECKED)
static void _UnloadOpenCL(EGLGlobal *psEGLGlobalData)
{
	if (psEGLGlobalData->bHaveOCLFunctions)
	{
		if (!UnloadModule(psEGLGlobalData->hOCLDrv))
		{
			PVR_DPF((PVR_DBG_WARNING, "_UnloadOpenCL: Failed to unload OCL module"));
		}

		psEGLGlobalData->bHaveOCLFunctions = IMG_FALSE;
	}
}
#endif /* (defined(SUPPORT_OPENCL) || defined(API_MODULES_RUNTIME_CHECKED) */
#endif /* Module unload region */

/***********************************************************************
 *
 *  FUNCTION   : _TlsInit()
 *  PURPOSE    : Initialise our thread local storage.
 *  PARAMETERS : In:  tls - Pointer to state structure.
 *  RETURNS    : None
 *
 ***********************************************************************/
IMG_INTERNAL IMG_BOOL _TlsInit(TLS psTls)
{
	EGLint      i;
	EGLGlobal   *psGlobalData;

	PVR_ASSERT(psTls!=IMG_NULL);

	psTls->lastError = EGL_NOT_INITIALIZED;

	for (i=0; i < IMGEGL_NUMBER_OF_APIS; i++)
	{
		psTls->apsCurrentReadSurface[i] = EGL_NO_SURFACE;
		psTls->apsCurrentDrawSurface[i] = EGL_NO_SURFACE;
		psTls->apsCurrentContext[i]     = EGL_NO_CONTEXT;
	}

	psTls->ui32ThreadID = IMGEGL_GetTLSID();

	psGlobalData = ENV_GetGlobalData();

	if(!psGlobalData)
	{
		IMG_UINT32  ui32DefaultPDSFragBufferSize  = EGL_DEFAULT_PDS_FRAG_BUFFER_SIZE;
		IMG_UINT32  ui32DefaultDriverMemorySize = 4 * 1024 * 1024;
		IMG_UINT32  ui32DefaultParamBufferSize    = EGL_DEFAULT_PARAMETER_BUFFER_SIZE;
		IMG_UINT32  ui32DefaultMaxParamBufferSize = EGL_DEFAULT_MAX_PARAMETER_BUFFER_SIZE;
		IMG_UINT32  ui32Default;
		IMG_VOID    *pvHintState;
		IMG_CHAR    szWSHint[APPHINT_MAX_STRING_SIZE], szWsHintDefault[1];;

		psGlobalData = ENV_CreateGlobalData(sizeof(EGLGlobal), GlobalDataDeinit);

		if(!psGlobalData)
		{
			goto ErrorExit;
		}

		/* Sanity checks: Should be zeroed by ENV_CreateGlobalData */
		for (i=0; i<EGL_MAX_NUM_DISPLAYS; i++)
		{
			PVR_ASSERT(psGlobalData->asDisplay[i].isInitialised       == EGL_FALSE);
			PVR_ASSERT(psGlobalData->asDisplay[i].bHasBeenInitialised == EGL_FALSE);
			PVR_ASSERT(psGlobalData->asDisplay[i].nativeDisplay       == (NativeDisplayType) EGL_NO_DISPLAY);
			PVR_ASSERT(psGlobalData->asDisplay[i].hWSDrv              == IMG_NULL);
		}

		PVR_ASSERT(psGlobalData->dpyCount == 0);
		PVR_ASSERT(psGlobalData->refCount == 0);

#		if defined(API_MODULES_RUNTIME_CHECKED)
		{
#if 1 /* Fast path without checking of contents of library file */
			/*  Only check that the library file is present, not that  */ 
			/*  it is actually a working driver.                       */
			PVR_DPF((PVR_DBG_MESSAGE,"Detecting driver modules:"));
			psGlobalData->bHaveOGLES1Functions = IMG_FALSE;
			psGlobalData->bHaveOGLES2Functions = IMG_FALSE;
			psGlobalData->bHaveOGLFunctions	= IMG_FALSE;
			psGlobalData->bHaveOVGFunctions = IMG_FALSE;
			psGlobalData->bHaveOCLFunctions = IMG_FALSE;
			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG] = IsOVGModulePresent();
			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1] = IsOGLES1ModulePresent();
			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2] = IsOGLES2ModulePresent();
			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL] = IsOGLModulePresent();
			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENCL] = IsOCLModulePresent();
			PVR_DPF((PVR_DBG_MESSAGE,"End of driver module detection."));
#else /* Slow path with full checking of contents of library file */
			/*  Try to load each client driver just to see which APIs   */
			/*  we can support. Unload each driver after testing.       */
			/*  After testing no client drivers are in memory, all      */
			/*  have API functions should be IMG_FALSE. Exceptionally   */
			/*  unloading might have failed though.                     */ 
			PVR_DPF((PVR_DBG_MESSAGE,"Detecting driver modules:"));
			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG] = LoadOVGAndGetFunctions(psGlobalData);
			_UnloadOpenVG(psGlobalData);
			if(psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG])
			{
				PVR_DPF((PVR_DBG_MESSAGE,"\tOpenVG driver module detected"));
			}

			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1] = LoadOGLES1AndGetFunctions(psGlobalData);
			_UnloadOpenGLES1(psGlobalData);
			if(psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1])
			{
				PVR_DPF((PVR_DBG_MESSAGE,"\tOpenGL ES 1 driver module detected"));
			}

			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2] = LoadOGLES2AndGetFunctions(psGlobalData);
			_UnloadOpenGLES2(psGlobalData);
			if(psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2])
			{
				PVR_DPF((PVR_DBG_MESSAGE,"\tOpenGL ES 2 driver module detected"));
			}

			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL] = LoadOGLAndGetFunctions(psGlobalData);
			_UnloadOpenGL(psGlobalData);
			if(psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL])
			{
				PVR_DPF((PVR_DBG_MESSAGE,"\tOpenGL driver module detected"));
			}

			psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENCL] = LoadOCLAndGetFunctions(psGlobalData);
			_UnloadOpenCL(psGlobalData);
			if(psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENCL])
			{
				PVR_DPF((PVR_DBG_MESSAGE,"\tOpenCL driver module detected"));
			}
			PVR_DPF((PVR_DBG_MESSAGE,"End of driver module detection."));
#endif
		}
#		else /* defined(API_MODULES_RUNTIME_CHECKED) */
		{

			/*  If API_MODULES_RUNTIME_CHECKED is defined the code above  */
			/*  will have already set have API functions properly.        */
			/*  If it is not defined, we hard code values to              */
			/*  psGlobalData->bApiModuleDetected[].                       */
#			if defined(SUPPORT_OPENGLES1)
			{
				psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1] = IMG_TRUE;
				psGlobalData->bHaveOGLES1Functions = IMG_FALSE;
		}
#			endif

#			if defined(SUPPORT_OPENGLES2)
			{
				psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2] = IMG_TRUE;
				psGlobalData->bHaveOGLES2Functions = IMG_FALSE;
			}
#			endif

#			if defined(SUPPORT_OPENGL)
			{
				psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL] = IMG_TRUE;
				psGlobalData->bHaveOGLFunctions	= IMG_FALSE;
			}
#			endif

#			if defined(SUPPORT_OPENVG)
			{
				psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG] = IMG_TRUE;
				psGlobalData->bHaveOVGFunctions = IMG_FALSE;
			}
#			endif

#			if defined(SUPPORT_OPENCL)
			{
				psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENCL] = IMG_TRUE;
				psGlobalData->bHaveOCLFunctions = IMG_FALSE;
			}
#			endif

		}
#		endif /* defined(API_MODULES_RUNTIME_CHECKED) */

		CFG_Initialise();

#		if (defined(SUPPORT_OPENGLES1) && defined(SUPPORT_OPENGLES2)) || defined(API_MODULES_RUNTIME_CHECKED)
		{
			psGlobalData->pfnMapBufferGLES1                         = IMG_NULL;
			psGlobalData->pfnMapBufferGLES2                         = IMG_NULL;
			psGlobalData->pfnUnmapBufferGLES1                       = IMG_NULL;
			psGlobalData->pfnUnmapBufferGLES2                       = IMG_NULL;
			psGlobalData->pfnGetBufferPointervGLES1                 = IMG_NULL;
			psGlobalData->pfnGetBufferPointervGLES2                 = IMG_NULL;
			psGlobalData->pfnEGLImageTargetTexture2DGLES1           = IMG_NULL;
			psGlobalData->pfnEGLImageTargetTexture2DGLES2           = IMG_NULL;
			psGlobalData->pfnEGLImageTargetRenderbufferStorageGLES1 = IMG_NULL;
			psGlobalData->pfnEGLImageTargetRenderbufferStorageGLES2 = IMG_NULL;
			psGlobalData->pfnMultiDrawArraysGLES1                   = IMG_NULL;
			psGlobalData->pfnMultiDrawArraysGLES2                   = IMG_NULL;
			psGlobalData->pfnMultiDrawElementsGLES1                 = IMG_NULL;
			psGlobalData->pfnMultiDrawElementsGLES2                 = IMG_NULL;
			psGlobalData->pfnBindVertexArrayGLES1                   = IMG_NULL;
			psGlobalData->pfnBindVertexArrayGLES2                   = IMG_NULL;
			psGlobalData->pfnDeleteVertexArrayGLES1                 = IMG_NULL;
			psGlobalData->pfnDeleteVertexArrayGLES2                 = IMG_NULL;
			psGlobalData->pfnGenVertexArrayGLES1                    = IMG_NULL;
			psGlobalData->pfnGenVertexArrayGLES2                    = IMG_NULL;
			psGlobalData->pfnIsVertexArrayGLES1                     = IMG_NULL;
			psGlobalData->pfnIsVertexArrayGLES2                     = IMG_NULL;
		}
#		endif /* (defined(SUPPORT_OPENGLES1) && defined(SUPPORT_OPENGLES2)) || defined(API_MODULES_RUNTIME_CHECKED) */

		/* Get application hints */
		PVRSRVCreateAppHintState(IMG_EGL, 0, &pvHintState);

		PVRSRVGetAppHint(pvHintState, "PDSFragBufferSize", IMG_UINT_TYPE,
						&ui32DefaultPDSFragBufferSize, &psGlobalData->sAppHints.ui32PDSFragBufferSize);

		PVRSRVGetAppHint(pvHintState, "ParamBufferSize", IMG_UINT_TYPE,
						&ui32DefaultParamBufferSize, &psGlobalData->sAppHints.ui32ParamBufferSize);

		PVRSRVGetAppHint(pvHintState, "DriverMemorySize", IMG_UINT_TYPE,
			&ui32DefaultDriverMemorySize, &psGlobalData->sAppHints.ui32DriverMemorySize);

		ui32Default = EXTERNAL_ZBUFFER_MODE_DEFAULT;

		PVRSRVGetAppHint(pvHintState, "ExternalZBufferMode", IMG_UINT_TYPE,
						&ui32Default, &psGlobalData->sAppHints.ui32ExternalZBufferMode);

		/*  This is not triggered by API_MODULES_RUNTIME_CHECKED */ 
#		if defined(SUPPORT_OPENVGX)
		{
			ui32Default = EXTERNAL_VGX_STENCIL_MODE_DEFAULT;
		
			PVRSRVGetAppHint(pvHintState, "ExternalVGXStencilBufferMode", IMG_UINT_TYPE,
							&ui32Default, &psGlobalData->sAppHints.ui32ExternalVGXStencilBufferMode);
		}
#		endif

#		if defined (API_MODULES_RUNTIME_CHECKED)
		{
			ui32Default = psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL] ? 100 : 50;
		}
#		else /* (API_MODULES_RUNTIME_CHECKED) */
		{
#			if defined (SUPPORT_OPENGL)
			{
				ui32Default = 100;
			}
#			else
			{
				ui32Default = 50;
			}
#			endif
		}
#		endif /* (API_MODULES_RUNTIME_CHECKED) */

		PVRSRVGetAppHint(pvHintState, "ExternalZBufferXSize", IMG_UINT_TYPE,
						&ui32Default, &psGlobalData->sAppHints.ui32DepthBufferXSize);
		PVRSRVGetAppHint(pvHintState, "ExternalZBufferYSize", IMG_UINT_TYPE,
						&ui32Default, &psGlobalData->sAppHints.ui32DepthBufferYSize);

		szWsHintDefault[0] = '\0';

		if (PVRSRVGetAppHint(pvHintState, "WindowSystem", IMG_STRING_TYPE, &szWsHintDefault, szWSHint))
		{
			sceClibStrncpy(psGlobalData->sAppHints.szWindowSystem, szWSHint, 256);
		}
		else
		{
			psGlobalData->sAppHints.szWindowSystem[0] = '\0';
		}

#		if defined (TIMING) || defined (DEBUG)
		{
			ui32Default = 0;
			PVRSRVGetAppHint(pvHintState, "DumpProfileData", IMG_UINT_TYPE, &ui32Default, &psGlobalData->sAppHints.bDumpProfileData);

			ui32Default = 0;
			PVRSRVGetAppHint(pvHintState, "ProfileStartFrame", IMG_UINT_TYPE, &ui32Default, &psGlobalData->sAppHints.ui32ProfileStartFrame);

			ui32Default = 0xFFFFFFFF;
			PVRSRVGetAppHint(pvHintState, "ProfileEndFrame", IMG_UINT_TYPE, &ui32Default, &psGlobalData->sAppHints.ui32ProfileEndFrame);

			ui32Default = 0;
			PVRSRVGetAppHint(pvHintState, "DisableMetricsOutput", IMG_UINT_TYPE, &ui32Default, &psGlobalData->sAppHints.bDisableMetricsOutput);

			InitIMGEGLMetrics(psTls);
		}
#		endif /* defined (TIMING) || defined (DEBUG) */

#if defined (SUPPORT_HYBRID_PB)
		ui32Default = 1;
		PVRSRVGetAppHint(pvHintState, "PerContextPB", IMG_UINT_TYPE, &ui32Default, &psGlobalData->sAppHints.bPerContextPB);
#endif
		PVRSRVFreeAppHintState(IMG_EGL, pvHintState);

	}

#	if defined(API_MODULES_RUNTIME_CHECKED)
	{
		psTls->ui32API = 
			(
				psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1] || 
				psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2]
			)
			? IMGEGL_API_OPENGLES
			: IMGEGL_API_NONE;
	}
#	else
	{
#		if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2)
		{
			psTls->ui32API = IMGEGL_API_OPENGLES;
		}
#		else
		{
			psTls->ui32API = IMGEGL_API_NONE;
		}
#		endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) */
	}
#	endif

	if(!psGlobalData->hEGLGlobalResource)
	{
		if (PVRSRVCreateMutex(&psGlobalData->hEGLGlobalResource) != PVRSRV_OK)
		{
			PVR_DPF((PVR_DBG_ERROR,"_TlsInit: PVRSRVCreateMutex failed"));

			goto ErrorDestroyGlobalData;
		}
	}

#	if defined(DEBUG)
	{
		if (!psGlobalData->hEGLMemTrackingResource)
		{
			if (PVRSRVCreateMutex(&psGlobalData->hEGLMemTrackingResource) != PVRSRV_OK)
			{
				PVR_DPF((PVR_DBG_ERROR,"_TlsInit: PVRSRVCreateMutex failed"));

				goto ErrorDestroyGlobalData;
			}
		}
	}
#	endif /* defined(DEBUG) */

	psGlobalData->refCount++;

	psTls->psGlobalData = psGlobalData;

	return IMG_TRUE;

ErrorDestroyGlobalData:
	ENV_DestroyGlobalData();
ErrorExit:
	return IMG_FALSE;
}


/***********************************************************************
 *
 *  FUNCTION   : _TlsDeInit()
 *  PURPOSE    : Initialise our thread local storage.
 *  PARAMETERS : In:  tls - Pointer to state structure.
 *  RETURNS    : None
 *
 ***********************************************************************/
static IMG_VOID _TlsDeInit(TLS psTls)
{
	EGLGlobal *psEGLGlobalData;

	psEGLGlobalData = psTls->psGlobalData;

	psEGLGlobalData->refCount--;

	if(psEGLGlobalData->refCount == 0)
	{
#		if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
		{
			_UnloadOpenGLES1(psEGLGlobalData);
		}
#		endif

#		if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
		{
			_UnloadOpenGLES2(psEGLGlobalData);
		}
#		endif

#		if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
		{
			_UnloadOpenGL(psEGLGlobalData);
		}
#		endif

#		if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)
		{
			_UnloadOpenVG(psEGLGlobalData);
		}
#		endif

#		if (defined(SUPPORT_OPENGLES1) && defined(SUPPORT_OPENGLES2)) || defined(API_MODULES_RUNTIME_CHECKED)
		{
			psEGLGlobalData->pfnMapBufferGLES1                          = IMG_NULL;
			psEGLGlobalData->pfnMapBufferGLES2                          = IMG_NULL;
			psEGLGlobalData->pfnUnmapBufferGLES1                        = IMG_NULL;
			psEGLGlobalData->pfnUnmapBufferGLES2                        = IMG_NULL;
			psEGLGlobalData->pfnGetBufferPointervGLES1                  = IMG_NULL;
			psEGLGlobalData->pfnGetBufferPointervGLES2                  = IMG_NULL;
			psEGLGlobalData->pfnEGLImageTargetTexture2DGLES1            = IMG_NULL;
			psEGLGlobalData->pfnEGLImageTargetTexture2DGLES2            = IMG_NULL;
			psEGLGlobalData->pfnEGLImageTargetRenderbufferStorageGLES1  = IMG_NULL;
			psEGLGlobalData->pfnEGLImageTargetRenderbufferStorageGLES2  = IMG_NULL;
			psEGLGlobalData->pfnMultiDrawArraysGLES1                    = IMG_NULL;
			psEGLGlobalData->pfnMultiDrawArraysGLES2                    = IMG_NULL;
			psEGLGlobalData->pfnMultiDrawElementsGLES1                  = IMG_NULL;
			psEGLGlobalData->pfnMultiDrawElementsGLES2                  = IMG_NULL;
		}
#		endif

#		if defined(SUPPORT_OPENCL) || defined(API_MODULES_RUNTIME_CHECKED)
		{
			_UnloadOpenCL(psEGLGlobalData);
		}
#		endif

#		if defined (TIMING) || defined (DEBUG)
		{
			OutputIMGEGLMetrics(psTls);
		}
#		endif /* defined (TIMING) || defined (DEBUG) */

		ENV_DestroyGlobalData();

		PVR_DPF((PVR_DBG_MESSAGE,"_TlsDeInit: Ref count is 0"));
	}
}


/***********************************************************************
 *
 *  FUNCTION   : GetKEGLDisplay()
 *  PURPOSE    : Search and verify the KEGL_DISPLAY record.
 *  PARAMETERS : In:  psTls
 *               In:  eglDpy
 *  RETURNS    : KEGL_DISPLAY or IMG_NULL
 *
 ***********************************************************************/
IMG_INTERNAL KEGL_DISPLAY * GetKEGLDisplay(TLS psTls, EGLDisplay eglDpy)
{
	EGLint         index;
	KEGL_DISPLAY * psDpy;

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		return (KEGL_DISPLAY *)0;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		return (KEGL_DISPLAY *)0;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		return (KEGL_DISPLAY *)0;
	}

	return psDpy;
}


/***********************************************************************
 *
 *  FUNCTION   : IsEGLContext()
 *  PURPOSE    : Search the contexts associated with a specified display for
 *               a given context to check handle validity.
 *  PARAMETERS : In:  psDpy - Display.
 *               In:  pInputContext - EGL context.
 *  RETURNS    : TRUE/FALSE.
 *
 ***********************************************************************/
IMG_INTERNAL IMG_BOOL IsEGLContext(KEGL_DISPLAY *psDpy, KEGL_CONTEXT *psInputContext)
{
	KEGL_CONTEXT *psContext;

	PVR_ASSERT(psDpy!=IMG_NULL);

	/* Let code after this deal with the valid no-context case.*/
	if(psInputContext == EGL_NO_CONTEXT)
	{
		return IMG_TRUE;
	}

	for (psContext = psDpy->psHeadContext; psContext!=IMG_NULL;
		 psContext = psContext->psNextContext)
	{
		if (psContext == psInputContext)
		{
			return IMG_TRUE;
		}
	}

	return IMG_FALSE;
}


/***********************************************************************
 *
 *  FUNCTION   : IsEGLSurface()
 *  PURPOSE    : Search the surfaces associated with a specified display for
 *               a given surface to check handle validity.
 *  PARAMETERS : In:  psDpy - Display.
 *               In:  pInputSurface - EGL surface.
 *  RETURNS    : TRUE/FALSE.
 *
 ***********************************************************************/
static IMG_BOOL IsEGLSurface(KEGL_DISPLAY *psDpy, KEGL_SURFACE *psInputSurface)
{
	KEGL_SURFACE *psSurface;

	PVR_ASSERT(psDpy!=IMG_NULL);

	/* Let code after this deal with the valid no-surface case.*/
	if(psInputSurface == EGL_NO_SURFACE)
	{
		return IMG_TRUE;
	}

	for (psSurface = psDpy->psHeadSurface; psSurface!=IMG_NULL;
		 psSurface = psSurface->psNextSurface)
	{
		if (psSurface == psInputSurface)
		{
			return IMG_TRUE;
		}
	}

	return IMG_FALSE;
}


/***********************************************************************
 *
 *  FUNCTION   : _FindWindowSurface()
 *  PURPOSE    : Search the surfaces associated with a specified display for
 *               the surface which represents a specified native window.
 *  PARAMETERS : In:  psDpy - Display.
 *               In:  window - Native window.
 *  RETURNS    : Surface or IMG_NULL.
 *
 ***********************************************************************/
static KEGL_SURFACE *_FindWindowSurface(KEGL_DISPLAY *psDpy, NativeWindowType window)
{
	KEGL_SURFACE *psSurface;

	PVR_ASSERT(psDpy!=IMG_NULL);

	for (psSurface = psDpy->psHeadSurface; psSurface!=IMG_NULL;
		 psSurface = psSurface->psNextSurface)
	{
		if ((psSurface->type == EGL_SURFACE_WINDOW) &&
			(psSurface->u.window.native == window))
		{
			return psSurface;
		}
	}

	return IMG_NULL;
}


/***********************************************************************
 *
 *  FUNCTION   : _FindPixmapSurface()
 *  PURPOSE    : Search the surfaces associated with a specified display for
 *               the surface which represents a specified native pixmap.
 *  PARAMETERS : In:  psDpy - Display.
 *  RETURNS    : In:  pixmap = Native pixmap.
 *
 ***********************************************************************/
static KEGL_SURFACE *_FindPixmapSurface(KEGL_DISPLAY *psDpy, NativePixmapType pixmap)
{
	KEGL_SURFACE *psSurface;

	PVR_ASSERT(psDpy!=IMG_NULL);

	for (psSurface = psDpy->psHeadSurface; psSurface!=IMG_NULL;
		 psSurface = psSurface->psNextSurface)
	{
		if (psSurface->type == EGL_SURFACE_PIXMAP
			&& psSurface->u.pixmap.native == pixmap)
		{
			return psSurface;
		}
	}

	return IMG_NULL;
}


/***********************************************************************
 *
 *  FUNCTION   : _InitialiseContextMode()
 *  PURPOSE    : Initialise a GLEScontextMode from an EGLConfig.
 *  PARAMETERS : Out: psCtx - Context mode to initialise.
 *             : In:  psCfg - Configuration.
 *  RETURNS    : None
 *
 ***********************************************************************/
static void _InitialiseContextMode(EGLcontextMode *psCtx, KEGL_CONFIG *psCfg)
{
	PVR_ASSERT(psCtx!=IMG_NULL);

	psCtx->ui32RedBits      = CFGC_GetAttrib(psCfg, EGL_RED_SIZE);
	psCtx->ui32GreenBits    = CFGC_GetAttrib(psCfg, EGL_GREEN_SIZE);
	psCtx->ui32BlueBits     = CFGC_GetAttrib(psCfg, EGL_BLUE_SIZE);
	psCtx->ui32AlphaBits    = CFGC_GetAttrib(psCfg, EGL_ALPHA_SIZE);

	psCtx->ui32ColorBits    = CFGC_GetAttrib(psCfg, EGL_BUFFER_SIZE);
	psCtx->ui32DepthBits    = CFGC_GetAttrib(psCfg, EGL_DEPTH_SIZE);
	psCtx->ui32StencilBits  = CFGC_GetAttrib(psCfg, EGL_STENCIL_SIZE);


	switch (CFGC_GetAttrib(psCfg, EGL_SAMPLE_BUFFERS))
	{
		case 0:
		{
			/* No anti-aliasing */
			psCtx->ui32AntiAliasMode=0;

			break;
		}
		case 1:
		{
			switch (CFGC_GetAttrib(psCfg, EGL_SAMPLES))
			{
				case 0:
				{
					psCtx->ui32AntiAliasMode=0;

					break;
				}
				case 2:
				{
					psCtx->ui32AntiAliasMode=IMG_ANTIALIAS_2x1;

					break;
				}
				case 4:
				{
					psCtx->ui32AntiAliasMode=IMG_ANTIALIAS_2x2;

					break;
				}
			}

			break;
		}
	}

	psCtx->ui32MaxViewportX = CFGC_GetAttrib(psCfg, EGL_MAX_PBUFFER_WIDTH);
	psCtx->ui32MaxViewportY = CFGC_GetAttrib(psCfg, EGL_MAX_PBUFFER_HEIGHT);
}


/***********************************************************************
 *
 *  FUNCTION   : _DpyContextUnlink()
 *  PURPOSE    : Unlink a context from a display.
 *  PARAMETERS : In:  psDpy -
 *               In:  psContext -
 *  RETURNS    : None
 *
 ***********************************************************************/
static void _DpyContextUnlink(KEGL_DISPLAY *psDpy, KEGL_CONTEXT *psContext)
{
	KEGL_CONTEXT **ppsCtx;

	PVR_ASSERT(psDpy!=IMG_NULL);
	PVR_ASSERT(psContext!=IMG_NULL);

	for (ppsCtx = &psDpy->psHeadContext; *ppsCtx!=IMG_NULL; ppsCtx = &((*ppsCtx)->psNextContext))
	{
		if (*ppsCtx == psContext)
		{
			*ppsCtx = psContext->psNextContext;

			return;
		}
	}
}


/***********************************************************************
 *
 *  FUNCTION   : _DpySurfaceUnlink()
 *  PURPOSE    : Unlink a surface from a display.
 *  PARAMETERS : In:  psDpy -
 *               In:  psSurface -
 *  RETURNS    : None
 *
 ***********************************************************************/
static void _DpySurfaceUnlink(KEGL_DISPLAY *psDpy, KEGL_SURFACE *psSurface)
{
	KEGL_SURFACE **ppsSurf;

	PVR_ASSERT(psDpy!=IMG_NULL);
	PVR_ASSERT(psSurface!=IMG_NULL);

	for (ppsSurf = &psDpy->psHeadSurface; *ppsSurf!=IMG_NULL; ppsSurf = &((*ppsSurf)->psNextSurface))
	{
		if (*ppsSurf == psSurface)
		{
			*ppsSurf = psSurface->psNextSurface;

			return;
		}
	}
}


/***********************************************************************
 *
 *  FUNCTION   : _ContextDelete
 *  PURPOSE    : Delete a context which is unbound.
 *  PARAMETERS : In:  psCtx - context to delete
 *  RETURNS    : None
 *
 **********************************************************************/
static EGLint _ContextDelete(KEGL_CONTEXT *psCtx, IMG_BOOL bAlreadyLocked)
{
	IMG_BOOL	imgResult;
	TLS			psTls = IMGEGLGetTLSValue();

	if (psTls==IMG_NULL)
	{
		PVR_DPF((PVR_DBG_ERROR,"_ContextDelete: No Current thread"));

		return EGL_NOT_INITIALIZED;
	}

	if(!bAlreadyLocked)
	{
		EGLThreadLock(psTls);
	}

	_DpyContextUnlink(psCtx->psDpy, psCtx);

	if(!bAlreadyLocked)
	{
		EGLThreadUnlock(psTls);
	}

#	if defined(API_MODULES_RUNTIME_CHECKED)
	{
		if(
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1] &&
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENGLES1)
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESDestroyGC)

			imgResult = psTls->psGlobalData->spfnOGLES1.pfnGLESDestroyGC(psCtx->hClientContext);
		}
		else if(
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2] &&
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENGLES2)
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES2Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES2.pfnGLESDestroyGC)

			imgResult = psTls->psGlobalData->spfnOGLES2.pfnGLESDestroyGC(psCtx->hClientContext);
		}
		else if(
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL] &&
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENGL)
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLDestroyGC)

			imgResult = psTls->psGlobalData->spfnOGL.pfnGLDestroyGC(psCtx->hClientContext);
		}
		else if(
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG] &&
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENVG)
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOVGFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOVG.pfnOVGDestroyGC)

			imgResult = psTls->psGlobalData->spfnOVG.pfnOVGDestroyGC(psCtx->hClientContext);
		}
		else
		{
			imgResult = IMG_FALSE;

			PVR_DPF((PVR_DBG_WARNING,"_ContextDelete: Invalid client API"));
		}

	}
#	else /* defined(API_MODULES_RUNTIME_CHECKED) */
	{

#		if defined(SUPPORT_OPENGLES1)
		if (psCtx->eContextType == IMGEGL_CONTEXT_OPENGLES1)
		{
			imgResult = psTls->psGlobalData->spfnOGLES1.pfnGLESDestroyGC(psCtx->hClientContext);
		}
		else
#		endif

#		if defined(SUPPORT_OPENGLES2)
		if (psCtx->eContextType == IMGEGL_CONTEXT_OPENGLES2)
		{
			imgResult = psTls->psGlobalData->spfnOGLES2.pfnGLESDestroyGC(psCtx->hClientContext);
		}
		else
#		endif

#		if defined(SUPPORT_OPENGL)
		if (psCtx->eContextType == IMGEGL_CONTEXT_OPENGL)
		{
			imgResult = psTls->psGlobalData->spfnOGL.pfnGLDestroyGC(psCtx->hClientContext);
		}
		else
#		endif

#		if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)
		if (psCtx->eContextType == IMGEGL_CONTEXT_OPENVG)
		{
			imgResult = psTls->psGlobalData->spfnOVG.pfnOVGDestroyGC(psCtx->hClientContext);
		}
		else
#		endif
		{
			imgResult = IMG_FALSE;

			PVR_DPF((PVR_DBG_WARNING,"_ContextDelete: Invalid client API"));
		}
	}
#	endif /* defined(API_MODULES_RUNTIME_CHECKED) */

	CFGC_Unlink(psCtx->psCfg);

	EGLFree(psCtx);

	/*
		Can this actually happen? If so we don't really have an appropriate
		error code to return, EGL_BAD_ALLOC may need to be reconsidered
	*/
	if (!imgResult)
	{
		return EGL_BAD_ALLOC;
	}

	return EGL_SUCCESS;
}


/***********************************************************************
 *
 *  FUNCTION   : _SurfaceDelete
 *  PURPOSE    : Delete a surface which is unbound.
 *  PARAMETERS : In:  psSurface - surface to delete.
 *  RETURNS    : None.
 *
 ***********************************************************************/
static void _SurfaceDelete(SrvSysContext *psSysContext, KEGL_SURFACE *psSurface)
{
	TLS psTls = IMGEGLGetTLSValue();

	if (psTls==IMG_NULL)
	{
		PVR_DPF((PVR_DBG_ERROR,"_SurfaceDelete: No Current thread"));

		return;
	}

	_DpySurfaceUnlink(psSurface->psDpy, psSurface);

	SRV_DestroySurface(psSysContext, psSurface);

	switch (psSurface->type)
	{
		case EGL_SURFACE_PBUFFER:
		{
#if defined(API_MODULES_RUNTIME_CHECKED)
			if(
				(psTls->ui32API == IMGEGL_API_OPENVG) && 
				psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG] &&
				psSurface->sRenderSurface.hVGClientBuffer
			)
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOVGFunctions)
				PVR_ASSERT(psTls->psGlobalData->spfnOVG.pfnOVGUnWrapImage)

				psTls->psGlobalData->spfnOVG.pfnOVGUnWrapImage(psSurface->sRenderSurface.hVGClientBuffer);
			}
			else
			{
				GWS_DeletePBufferDrawable(psSurface, psSysContext);
			}
#else /* defined(API_MODULES_RUNTIME_CHECKED) */

#	if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)
			if((psTls->ui32API == IMGEGL_API_OPENVG) && psSurface->sRenderSurface.hVGClientBuffer)
			{
				psTls->psGlobalData->spfnOVG.pfnOVGUnWrapImage(psSurface->sRenderSurface.hVGClientBuffer);
			}
			else
#	endif /* defined(SUPPORT_OPENVG) */
			{
				GWS_DeletePBufferDrawable(psSurface, psSysContext);
			}
#endif /* defined(API_MODULES_RUNTIME_CHECKED) */

			break;
		}
		case EGL_SURFACE_WINDOW:
		{

			EGLReleaseThreadLockWSEGL(psSurface->psDpy, psTls);

			psSurface->psDpy->pWSEGL_FT->pfnWSEGL_DeleteDrawable(psSurface->u.window.hDrawable);
			EGLFree(psSurface->u.window.native);

			EGLReacquireThreadLockWSEGL(psSurface->psDpy, psTls);

			break;
		}
		default:
		{
			psSurface->psDpy->pWSEGL_FT->pfnWSEGL_DeleteDrawable(psSurface->u.pixmap.hDrawable);

			break;
		}
	}

	CFGC_Unlink(psSurface->psCfg);

	EGLFree(psSurface);
}


/***********************************************************************
 *
 *  FUNCTION   : _CompatibleContextAndSurface
 *  PURPOSE    : From k-egl specification section 2.2. A context and a
 *               surface are considered compatible if they:
 *               - have colour and ancillary buffers of the same depth
 *               - were created with respect to the same display.
 *  PARAMETERS : In:  psCtx -
 *               In:  psSurface -
 *  RETURNS    : EGL_TRUE - Compatible.
 *               EGL_FALSE - Not compatible.
 *
 ***********************************************************************/
static EGLBoolean _CompatibleContextAndSurface(KEGL_CONTEXT *psCtx, KEGL_SURFACE *psSurface)
{
	PVR_ASSERT(psCtx!=IMG_NULL);
	PVR_ASSERT(psSurface!=IMG_NULL);

	if (psCtx->psDpy != psSurface->psDpy)
	{
		return EGL_FALSE;
	}

	return CFG_CompatibleConfigs(psCtx->psCfg, psSurface->psCfg, (psCtx->eContextType == IMGEGL_CONTEXT_OPENVG) ? IMG_TRUE : IMG_FALSE);
}


/***********************************************************************
 *
 *  FUNCTION   : _SurfaceUnbind
 *  PURPOSE    : Unbind a surface. A surface which is marked as 'isDeleting'
 *               which becomes completely unbound is deleted.
 *  PARAMETERS : In:  psSysContext - system context
 *               In:  psSurface - Surface to delete.
 *  RETURNS    : None
 *
 **********************************************************************/
static void _SurfaceUnbind(SrvSysContext *psSysContext, KEGL_SURFACE *psSurface)
{
	psSurface->refCount--;
	psSurface->currentCount--;

	if (psSurface->refCount==0)
	{
		PVR_ASSERT(psSurface->currentCount == 0);
		if (psSurface->isDeleting)
		{
			_SurfaceDelete(psSysContext, psSurface);
		}
	}
}

/***********************************************************************
 *
 *  FUNCTION   : _FindContextByThreadID
 *  PURPOSE    : Finds a context from the global list which is currently bound to a specific thread.
 *  PARAMETERS : In:  psDpy - Display
				 In:  threadID - thread to test against.
 *  RETURNS    : psContext - Context is bound to specific thread.
 *               NULL - Context is not bound to specific thread.
 *
 **********************************************************************/

#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)

static KEGL_CONTEXT * _FindContextByThreadID(KEGL_DISPLAY *psDpy, EGLint threadID)
{
	KEGL_CONTEXT *psCtx;

	for (psCtx = psDpy->psHeadContext; psCtx!=IMG_NULL; psCtx = psCtx->psNextContext)
	{
		if ((psCtx != EGL_NO_CONTEXT) &&
			psCtx->isCurrent &&
			(psCtx->boundThread == threadID))
		{
			return psCtx;
		}
	}

	return IMG_NULL;
}

#endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */


/***********************************************************************
 *
 *  FUNCTION   : _ContextBoundToOtherThread
 *  PURPOSE    : Test is a context is currently bound to another thread.
 *  PARAMETERS : In:  psCtx - Context to test.
 *  RETURNS    : EGL_TRUE - Context is bound to another thread.
 *               EGL_FALSE - Context is not bound to another thread.
 *
 **********************************************************************/
static EGLBoolean _ContextBoundToOtherThread(KEGL_CONTEXT *psCtx)
{
	if ((psCtx != EGL_NO_CONTEXT) &&
		 psCtx->isCurrent &&
		(psCtx->boundThread != (EGLint)IMGEGL_GetTLSID()))
	{
		return EGL_TRUE;
	}

	return EGL_FALSE;
}


/***********************************************************************
 *
 *  FUNCTION   : _SurfaceBoundToOtherThread
 *  PURPOSE    : Test if a surface is currently bound to another thread.
 *  PARAMETERS : In:  psSurface - Surface to test.
 *  RETURNS    : EGL_TRUE - Surface is bound to another thread.
 *               EGL_FALSE - Surface is not bound to another thread.
 *
 **********************************************************************/
static EGLBoolean _SurfaceBoundToOtherThread(KEGL_SURFACE *psSurface)
{
	if ((psSurface != EGL_NO_SURFACE) &&
		(psSurface->currentCount > 0) &&
		(psSurface->boundThread != (EGLint)IMGEGL_GetTLSID()))
	{
		return EGL_TRUE;
	}

	return EGL_FALSE;
}


/***********************************************************************
 *
 *  FUNCTION   : _ValidateAttribList
 *  PURPOSE    : Ensure that an attribute list contains only recognised
 *               attributes.
 *  PARAMETERS : In:  pAttribList - attribute list to validate.
 *               Out: pnListCount - attribute list size
 *  RETURNS    : EGL_SUCCESS or EGL_BAD_PARAMETER
 *
 **********************************************************************/
static EGLint _ValidateAttribList(const EGLint *pAttribList, EGLint *pnListCount)
{
	const EGLint *pAttribListStart = pAttribList;
	EGLint nEglError = EGL_SUCCESS;
	EGLint iAttributeName, iAttributeValue;

	if (pAttribList!=IMG_NULL)
	{
		while (*pAttribList!=EGL_NONE)
		{
			iAttributeName=*pAttribList;
			iAttributeValue=*(pAttribList+1);

			switch(iAttributeName)
			{

				/* handle the cases where negative values (except EGL_DONT_CARE)
				 * are out of range
				 */
				case EGL_BUFFER_SIZE: /* should we check for conflict with red+green+blue+alpha size ? */
				case EGL_ALPHA_SIZE:
				case EGL_BLUE_SIZE:
				case EGL_GREEN_SIZE:
				case EGL_RED_SIZE:
				case EGL_ALPHA_MASK_SIZE:
				case EGL_LUMINANCE_SIZE:
				case EGL_DEPTH_SIZE:
				case EGL_STENCIL_SIZE:
				case EGL_CONFIG_ID:
				case EGL_MAX_PBUFFER_HEIGHT:
				case EGL_MAX_PBUFFER_PIXELS:
				case EGL_MAX_PBUFFER_WIDTH:
				case EGL_SAMPLES: /* perhaps we should be checking this == 0 if EGL_SAMPLE_BUFFERS == 0 ? */
				case EGL_TRANSPARENT_BLUE_VALUE: /* should it be validated against any EGL_BLUE_SIZE? */
				case EGL_TRANSPARENT_GREEN_VALUE: /* should it be validated against any EGL_GREEN_SIZE? */
				case EGL_TRANSPARENT_RED_VALUE: /* should it be validated against any EGL_RED_SIZE? */
				case EGL_MIN_SWAP_INTERVAL:
				case EGL_MAX_SWAP_INTERVAL:

					if( iAttributeValue != EGL_DONT_CARE && iAttributeValue < 0 )
					{
						nEglError = EGL_BAD_ATTRIBUTE;
					}

					break;


				/* handle booleans
				 */
				case EGL_NATIVE_RENDERABLE:
				case EGL_BIND_TO_TEXTURE_RGB:
				case EGL_BIND_TO_TEXTURE_RGBA:
#if defined(EGL_EXTENSION_ANDROID_RECORDABLE)
				case EGL_RECORDABLE_ANDROID:
#endif

					if( iAttributeValue != EGL_DONT_CARE
						&& iAttributeValue != EGL_TRUE
						&& iAttributeValue != EGL_FALSE)
					{
						nEglError = EGL_BAD_ATTRIBUTE;
					}

					break;


				/* handle the more special cases
				 */
				case EGL_CONFIG_CAVEAT:

					if( iAttributeValue != EGL_DONT_CARE
						&& iAttributeValue != EGL_NONE
						&& iAttributeValue != EGL_SLOW_CONFIG
						&& iAttributeValue != EGL_NON_CONFORMANT_CONFIG)
					{
						nEglError = EGL_BAD_ATTRIBUTE;
					}

					break;
				case EGL_SAMPLE_BUFFERS:

					if( iAttributeValue != EGL_DONT_CARE
						&& iAttributeValue != 0
						&& iAttributeValue != 1)
					{
						nEglError = EGL_BAD_ATTRIBUTE;
					}

					break;
				case EGL_SURFACE_TYPE:

					if( iAttributeValue != EGL_DONT_CARE
						&& (iAttributeValue & ~(EGL_WINDOW_BIT               |
												EGL_PIXMAP_BIT               |
												EGL_PBUFFER_BIT				 |
												EGL_VG_COLORSPACE_LINEAR_BIT |
												EGL_VG_ALPHA_FORMAT_PRE_BIT  |
												EGL_MULTISAMPLE_RESOLVE_BOX_BIT |
												EGL_SWAP_BEHAVIOR_PRESERVED_BIT)) != 0)
					{
						nEglError = EGL_BAD_ATTRIBUTE;
					}

					break;
				case EGL_TRANSPARENT_TYPE:

					if( iAttributeValue != EGL_DONT_CARE
						&& iAttributeValue != EGL_NONE
						&& iAttributeValue != EGL_TRANSPARENT_RGB)
					{
						nEglError = EGL_BAD_ATTRIBUTE;
					}

					break;
				case EGL_LEVEL:

					/*
					 * The k-egl specification states that EGL_LEVEL may not
					 * be set to EGL_DONT_CARE
					 *
					 * It also looks like it may be valid to want an EGL_LEVEL
					 * of -1 (for underlays) which this would conflict with.
					*/

					if( iAttributeValue == EGL_DONT_CARE )
					{
						nEglError = EGL_BAD_ATTRIBUTE;
					}

					break;


				/* cases that may have any value and don't need validating here
				 */
				case EGL_NATIVE_VISUAL_ID:
				case EGL_NATIVE_VISUAL_TYPE:
				case EGL_MATCH_NATIVE_PIXMAP:
					break;
				case EGL_RENDERABLE_TYPE:
				case EGL_CONFORMANT:

					if( iAttributeValue != EGL_DONT_CARE
						&& (iAttributeValue & ~(EGL_OPENGL_ES_BIT |
												EGL_OPENGL_ES2_BIT |
												EGL_OPENGL_BIT |
												EGL_OPENVG_BIT)) != 0
						)
					{
						nEglError = EGL_BAD_ATTRIBUTE;
					}

					break;
				case EGL_COLOR_BUFFER_TYPE:

					if( iAttributeValue != EGL_DONT_CARE
						&& iAttributeValue != EGL_RGB_BUFFER
						&& iAttributeValue != EGL_LUMINANCE_BUFFER
						)
					{
						nEglError = EGL_BAD_ATTRIBUTE;
					}

					break;



				/* invalid attribute names fall through here
				 */
				default:
					nEglError = EGL_BAD_ATTRIBUTE;
					break;
			}

			if ( nEglError != EGL_SUCCESS )
			{
				break;
			}

			pAttribList += 2;
		}
	}

	/* Return the number of elements (identifiers + values) in list */
	*pnListCount = (pAttribList - pAttribListStart);

	return nEglError;
}


/***********************************************************************
 *
 *  FUNCTION   : KEGLSurfaceUnbind
 *  PURPOSE    : Unbind a surface. A surface which is marked as 'isDeleting'
 *               which becomes completely unbound is deleted.
 *  PARAMETERS : In:  pvrsrv - system context
 *               In:  psSurface - Surface to delete.
 *  RETURNS    : None
 *
 **********************************************************************/
IMG_EXPORT IMG_VOID IMG_CALLCONV KEGLSurfaceUnbind(SrvSysContext *psSysContext, IMG_HANDLE hSurface)
{
	KEGL_SURFACE *psSurface = (KEGL_SURFACE *)hSurface;
	TLS psTls = IMGEGLGetTLSValue();

	if (psTls==IMG_NULL)
	{
		return;
	}

	psSurface->refCount--;

	EGLThreadLock(psTls);

	if (psSurface->refCount==0)
	{
		PVR_ASSERT(psSurface->currentCount == 0);
		if (psSurface->isDeleting)
		{
			_SurfaceDelete(psSysContext, psSurface);
		}
	}

	EGLThreadUnlock(psTls);
}


/***********************************************************************
 *
 *  FUNCTION   : KEGLSurfaceBind
 *  PURPOSE    : Called when a surface is bound.
 *  PARAMETERS : In:  psSurface - Surface being bound
 *  RETURNS    : None
 *
 **********************************************************************/
IMG_EXPORT IMG_VOID IMG_CALLCONV KEGLSurfaceBind(IMG_HANDLE hSurface)
{
	KEGL_SURFACE *psSurface = (KEGL_SURFACE *)hSurface;

	psSurface->refCount++;
}


/***********************************************************************
 *
 *  FUNCTION   : eglGetError
 *  PURPOSE    : Khronos EGL API
 *               Request the last error code.
 *  PARAMETERS : None.
 *  RETURNS    : The last error code returned from a Khronos EGL API call made
 *               by the current thread.
 *
 **********************************************************************/
IMG_EXPORT EGLint IMGeglGetError(void)
{
	TLS psTls = IMGEGLGetTLSValue();
	EGLint iReturnValue;

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglGetError"));

	if (psTls==IMG_NULL)
	{
		return EGL_SUCCESS;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglGetError);

	iReturnValue = psTls->lastError;

	psTls->lastError = EGL_SUCCESS;

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetError);

	return iReturnValue;
}


/***********************************************************************
 *
 *  FUNCTION   : eglGetDisplay
 *  PURPOSE    : Retrieve the EGLDisplay for the specified native display.
 *               This API entry point operates outside of the eglInitialise,
 *               eglTerminate region and therefore does not set any error
 *               code for retrieval by eglGetError.
 *  PARAMETERS : In:  nativeDisplay
 *  RETURNS    : EGLDisplay or EGL_NO_DISPLAY
 *
 **********************************************************************/
IMG_EXPORT EGLDisplay IMGeglGetDisplay(NativeDisplayType nativeDisplay)
{
	TLS psTls;
	EGLDisplay eglDpy;
	IMG_UINT32 ui32Slot;
	KEGL_DISPLAY *psDisplay;
	IMG_BOOL bSeenBefore;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglGetDisplay"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_NO_DISPLAY;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglGetDisplay);

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetDisplay);

		return EGL_FALSE;
	}
#endif

	EGLThreadLock(psTls);

	psTls->lastError = EGL_SUCCESS;

	psDisplay = psTls->psGlobalData->asDisplay;
	bSeenBefore = IMG_FALSE;

	/*
		Check to see if the native display handle has been registered.
		As there is no way to UnGet a Display (and remove it from the list),
		we look through the list until we find a match or an unused slot.
	*/
	for (ui32Slot = 0; ui32Slot < EGL_MAX_NUM_DISPLAYS; ui32Slot++)
	{
		if (psDisplay[ui32Slot].nativeDisplay == nativeDisplay)
		{
			/* Already registered */
			if (psDisplay[ui32Slot].pWSEGL_FT)
			{
				/* If pWSEGL_FT has been set, then we've used this Display */
				bSeenBefore = IMG_TRUE;
			}
			goto FoundSlot;
		}

		if (psDisplay[ui32Slot].pWSEGL_FT == IMG_NULL)
		{
			/* First free slot => no more registered displays */
			goto FoundSlot;
		}
	}

	PVR_DPF((PVR_DBG_WARNING,"IMGeglGetDisplay: No free slots (%d used)", ui32Slot));

	EGLThreadUnlock(psTls);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetDisplay);

	return EGL_NO_DISPLAY;

FoundSlot:

	if (!psDisplay[ui32Slot].hWSDrv)
	{
		IMG_BOOL bWSModuleLoaded;
		/*
		 * Load a window-system module for the nativeDisplay type - this also
		 * validates the display by invoking the module's IsDisplayValid method
		 */
		bWSModuleLoaded = LoadWSModule(&psTls->psGlobalData->sSysContext,
									   &psDisplay[ui32Slot],
									   &psDisplay[ui32Slot].hWSDrv,
									   nativeDisplay,
									   &psTls->psGlobalData->sAppHints.szWindowSystem[0]);

		if (!bWSModuleLoaded)
		{
			psDisplay[ui32Slot].hWSDrv = IMG_NULL;

			EGLThreadUnlock(psTls);

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetDisplay);

			return EGL_NO_DISPLAY;
		}

		if (!bSeenBefore)
		{
			/* This Display has been 'Got' before and been terminated */
			psTls->psGlobalData->dpyCount++;
			PVR_ASSERT(psTls->psGlobalData->dpyCount <= EGL_MAX_NUM_DISPLAYS);
		}
	}

	eglDpy = SLOT_INDEX_TO_EGLDISPLAY(ui32Slot);

	psDisplay[ui32Slot].nativeDisplay = nativeDisplay;

	EGLThreadUnlock(psTls);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetDisplay);

	return (eglDpy);
}


/***********************************************************************
 *
 *  FUNCTION   : eglInitialise
 *  PURPOSE    : API. Initialise a display.
 *  PARAMETERS : In:  eglDpy
 *               In:  major
 *               In:  minor
 *  RETURNS    : EGL_TRUE - success
 *               EGL_FALSE - failure
 *
 ***********************************************************************/
IMG_EXPORT EGLBoolean IMGeglInitialize(EGLDisplay eglDpy, EGLint *major, EGLint *minor)
{
	const WSEGLCaps *psCapabilities;
	WSEGLConfig     *psConfigs;
	KEGL_DISPLAY    *psDpy;
	TLS             psTls;
	EGLint          index;
	IMG_BOOL        bServicesInit = IMG_FALSE;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglInitialize"));

	psTls = TLS_Open(_TlsInit);
	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglInitialize);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglInitialize);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglInitialize);
		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);
	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglInitialize);
		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	EGLThreadLock(psTls);

	if(!psTls->psGlobalData->sSysContext.psConnection)
	{
#if defined(TIMING) || defined(DEBUG)
		if (!SRV_ServicesInit(&psTls->psGlobalData->sSysContext, &psTls->psGlobalData->sAppHints, psTls->fCPUSpeed))
#else
		if (!SRV_ServicesInit(&psTls->psGlobalData->sSysContext, &psTls->psGlobalData->sAppHints, 0.0f))
#endif
		{
			EGLThreadUnlock(psTls);
			psTls->lastError = EGL_BAD_ALLOC;
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglInitialize);
			return EGL_FALSE;
		}

		bServicesInit = IMG_TRUE;
	}

	if (!psDpy->isInitialised)
	{
		if (!psDpy->hWSDrv)
		{
			if (!LoadWSModule(&psTls->psGlobalData->sSysContext,
							  psDpy, &psDpy->hWSDrv,
							  psDpy->nativeDisplay,
							  &psTls->psGlobalData->sAppHints.szWindowSystem[0]))
			{
				psDpy->hWSDrv = IMG_NULL;
				psTls->lastError = EGL_NOT_INITIALIZED;
				goto Srv_DeInit;
			}
		}

		if (psDpy->pWSEGL_FT->pfnWSEGL_InitialiseDisplay(psDpy->nativeDisplay,
														&psDpy->hDisplay,
														&psCapabilities,
														&psConfigs)!=WSEGL_SUCCESS)
		{
			psTls->lastError = EGL_NOT_INITIALIZED;
		}
		else
		{
			psDpy->psCapabilities   = psCapabilities;
			psDpy->psConfigs        = psConfigs;
			psDpy->ui32NumConfigs   = 0;
			while (psConfigs->ui32DrawableType!=WSEGL_NO_DRAWABLE)
			{
				psDpy->ui32NumConfigs++;
				psConfigs++;
			}

			/*
			// Set up some defaults
			*/
			psDpy->ui32MinSwapInterval = 1;
			psDpy->ui32MaxSwapInterval = 1;
			psDpy->bUseHWForWindowSync = IMG_FALSE;
			psDpy->bUseHWForPixmapSync = IMG_FALSE;
			psDpy->bUnlockedWSEGL = IMG_FALSE;
#if defined(EGL_EXTENSION_KHR_FENCE_SYNC)
			psDpy->psHeadSync = IMG_NULL;
#endif

			while (psCapabilities->eCapsType!=WSEGL_NO_CAPS)
			{
				switch (psCapabilities->eCapsType)
				{
					case WSEGL_CAP_MIN_SWAP_INTERVAL:
					{
						psDpy->ui32MinSwapInterval = psCapabilities->ui32CapsValue;
						break;
					}
					case WSEGL_CAP_MAX_SWAP_INTERVAL:
					{
						psDpy->ui32MaxSwapInterval = psCapabilities->ui32CapsValue;
						break;
					}
					case WSEGL_CAP_WINDOWS_USE_HW_SYNC:
					{
						psDpy->bUseHWForWindowSync = !psCapabilities->ui32CapsValue ? IMG_FALSE : IMG_TRUE;
						break;
					}
					case WSEGL_CAP_PIXMAPS_USE_HW_SYNC:
					{
						psDpy->bUseHWForPixmapSync = !psCapabilities->ui32CapsValue ? IMG_FALSE : IMG_TRUE;
						break;
					}
					case WSEGL_CAP_UNLOCKED:
					{
						psDpy->bUnlockedWSEGL = psCapabilities->ui32CapsValue ? IMG_TRUE : IMG_FALSE;
						break;
					}
					default:
					{
						PVR_DPF((PVR_DBG_WARNING, "IMGeglInitialize:  Unknown caps type %d",psCapabilities->eCapsType));
						break;
					}
				}

				psCapabilities++;
			}
		}

		if (psTls->lastError != EGL_SUCCESS)
		{
			goto Srv_DeInit;
		}

		psDpy->isInitialised = EGL_TRUE;

		if(psDpy->bHasBeenInitialised == IMG_FALSE)
		{
		  psDpy->psHeadSurface = IMG_NULL;
		  psDpy->psHeadContext = IMG_NULL;
		  psDpy->bHasBeenInitialised = EGL_TRUE;
		}

	}

	EGLThreadUnlock(psTls);
	if (major!=IMG_NULL)
	{
		*major = 1;
	}
	if (minor!=IMG_NULL)
	{
		*minor = 4;
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglInitialize);

	return EGL_TRUE;

Srv_DeInit:

	if(bServicesInit)
	{
		if(psDpy->hWSDrv)
		{
			UnloadModule(psDpy->hWSDrv);
			psDpy->hWSDrv = IMG_NULL;
		}
		SRV_ServicesDeInit(&psTls->psGlobalData->sSysContext);
	}

	EGLThreadUnlock(psTls);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglInitialize);

	return EGL_FALSE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglTerminate
 *  PURPOSE    : Terminate a display.
 *  PARAMETERS : In:  eglDpy
 *  RETURNS    : EGL_TRUE - success.
 *               EGL_FALSE - failure.
 *
 ***********************************************************************/
IMG_EXPORT EGLBoolean IMGeglTerminate(EGLDisplay eglDpy)
{
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	EGLint index;
	EGLBoolean returnstatus = EGL_TRUE;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglTerminate"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglTerminate);

	psTls->lastError = EGL_SUCCESS;

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglTerminate);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglTerminate);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	EGLThreadLock(psTls);

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		IMGeglAwakenProcessIMG();
	}
#endif

	if(psDpy->isInitialised)
	{
		IMG_BOOL bClose = IMG_TRUE;
		KEGL_SURFACE *psSurface = psDpy->psHeadSurface;
		KEGL_CONTEXT *psContext = psDpy->psHeadContext;

#if defined(EGL_EXTENSION_KHR_IMAGE)
		TerminateImages(psDpy);
#endif /* defined(EGL_EXTENSION_KHR_IMAGE) */

#if defined(EGL_EXTENSION_KHR_FENCE_SYNC) || defined(EGL_EXTENSION_KHR_REUSABLE_SYNC)
		TerminateSyncs(psDpy, &psTls->psGlobalData->sSysContext);
#endif

		/* search the surfaces associated with a specified display and mark or delete */
		while(psSurface)
		{
			KEGL_SURFACE *psNextSurface = psSurface->psNextSurface;

			if(psSurface->psDpy == psDpy)
			{
				/* if it's used release later otherwise delete */
				if (psSurface->refCount==0)
				{
					_SurfaceDelete(&psTls->psGlobalData->sSysContext, psSurface);
				}
				else
				{
					psSurface->isDeleting = EGL_TRUE;
					bClose = IMG_FALSE;
				}
			}

			psSurface = psNextSurface;
		}

		/* search the contexts associated with a specified display and mark or delete */
		while(psContext)
		{
			KEGL_CONTEXT *psNextContext = psContext->psNextContext;

			if(psContext->psDpy == psDpy)
			{
				/* if it's current release later otherwise delete */
				if (psContext->isCurrent!=EGL_TRUE)
				{
					_ContextDelete(psContext, IMG_TRUE);
				}
				else
				{
					psContext->isDeleting = EGL_TRUE;
					bClose = IMG_FALSE;
				}
			}

			psContext = psNextContext;
		}

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
		/*
			Give OpenGL a chance to free remaining resources asociated with the current
			device memory context
		*/

		if (bClose)
		{
			if(psTls->psGlobalData->bHaveOGLFunctions && psTls->psGlobalData->spfnOGL.pfnGLFreeResources)
			{
				if (!psTls->psGlobalData->spfnOGL.pfnGLFreeResources(&psTls->psGlobalData->sSysContext))
				{
					/* Could not free resources */
					bClose = IMG_FALSE;
				}
			}
		}

#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)) */

		if (bClose)
		{
			IMG_BOOL bDeInitServices = IMG_TRUE;

			psDpy->pWSEGL_FT->pfnWSEGL_CloseDisplay(psDpy->hDisplay);

			psDpy->hDisplay = IMG_NULL;

			psDpy->isInitialised = EGL_FALSE;


			/* Check if a display is still initialised */
			for(index = 0; index < psTls->psGlobalData->dpyCount; index++)
			{
				if(psTls->psGlobalData->asDisplay[index].isInitialised)
				{
					bDeInitServices = IMG_FALSE;
				}
			}

			if(bDeInitServices)
			{
				SRV_ServicesDeInit(&psTls->psGlobalData->sSysContext);
			}

			UnloadModule(psDpy->hWSDrv);

			psDpy->hWSDrv = IMG_NULL;

			EGLThreadUnlock(psTls);

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglTerminate);

			TLS_Close(_TlsDeInit);
		}
		else
		{
			EGLThreadUnlock(psTls);

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglTerminate);
		}
	}
	else
	{
		EGLThreadUnlock(psTls);

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglTerminate);

		TLS_Close(_TlsDeInit);
	}

	return returnstatus;
}

/***********************************************************************
 *
 *  FUNCTION   : eglQueryString
 *  PURPOSE    : Query one of the predefined strings associated with a display.
 *  PARAMETERS : In:  eglDpy - Display handle to query.
 *               In:  name - String identifier.
 *  RETURNS    : Queried string or IMG_NULL.
 *
 **********************************************************************/
IMG_EXPORT const char * IMGeglQueryString(EGLDisplay eglDpy, EGLint name)
{
	KEGL_DISPLAY	*psDpy;
	TLS				psTls;
	EGLint			index;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglQueryString"));

	psTls = TLS_Open(_TlsInit);
	if (psTls==IMG_NULL)
	{
		return IMG_NULL;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglQueryString);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryString);

		return IMG_NULL;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryString);
		return IMG_NULL;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);
	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryString);
		return IMG_NULL;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];
	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryString);
		return IMG_NULL;
	}

	switch (name)
	{
		case EGL_VENDOR:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryString);

			return "Imagination Technologies";
		}
		case EGL_VERSION:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryString);

			return "1.4 build "PVRVERSION_STRING_SHORT;
		}
		case EGL_EXTENSIONS:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryString);

			return
				""
#if defined(SUPPORT_OPENGL)
				"EGL_IMG_client_api_ogl "
#endif /* defined(SUPPORT_OPENGL) */
#if defined(EGL_EXTENSION_KHR_IMAGE)
				"EGL_KHR_image "
				"EGL_KHR_image_base "
	#if defined(EGL_EXTENSION_KHR_GL_TEXTURE_2D_IMAGE)
				"EGL_KHR_gl_texture_2D_image "
	#endif /* defined(EGL_EXTENSION_KHR_GL_TEXTURE_2D_IMAGE) */
	#if defined(EGL_EXTENSION_KHR_GL_TEXTURE_CUBEMAP_IMAGE)
				"EGL_KHR_gl_texture_cubemap_image "
	#endif /* defined(EGL_EXTENSION_KHR_GL_TEXTURE_CUBEMAP_IMAGE) */
	#if defined(EGL_EXTENSION_KHR_GL_RENDERBUFFER_IMAGE)
				"EGL_KHR_gl_renderbuffer_image "
	#endif /* defined(EGL_EXTENSION_KHR_GL_RENDERBUFFER_IMAGE) */
	#if defined(EGL_EXTENSION_KHR_VG_PARENT_IMAGE)
				"EGL_KHR_vg_parent_image "
	#endif /* defined(EGL_EXTENSION_KHR_VG_PARENT_IMAGE) */
	#if defined(EGL_EXTENSION_IMG_CL_IMAGE)
				"EGL_IMG_cl_image "
	#endif /* defined(EGL_EXTENSION_IMG_CL_IMAGE) */
#if defined(EGL_EXTENSION_ANDROID_BLOB_CACHE) 
				"EGL_ANDROID_blob_cache "
#endif
	#if defined(ANDROID)
				"EGL_ANDROID_image_native_buffer "
	#endif /* defined(ANDROID) */
#endif /* defined(EGL_EXTENSION_KHR_IMAGE) */
#if defined(EGL_EXTENSION_ANDROID_RECORDABLE)
				"EGL_ANDROID_recordable "
#endif
#if defined(EGL_EXTENSION_KHR_FENCE_SYNC)
				"EGL_KHR_fence_sync "
#endif /* defined(EGL_EXTENSION_KHR_FENCE_SYNC) */
#if defined(EGL_EXTENSION_KHR_REUSABLE_SYNC)
				"EGL_KHR_reusable_sync "
#endif /* defined(EGL_EXTENSION_KHR_REUSABLE_SYNC) */
#if defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)
				"EGL_IMG_context_priority "
#endif
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
				"EGL_IMG_hibernate_process "
#endif
				;
		}
		case EGL_CLIENT_APIS:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryString);
#if defined(API_MODULES_RUNTIME_CHECKED)

			{
				IMG_BOOL es =
					psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1] ||
					psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2];
				IMG_BOOL ogl = psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL];
				IMG_BOOL ovg = psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG];

				/* Somewhat odd code but no runtime string manipulation. */
				/* You probably should not reorder the lines below.      */
				if(es && ovg && ogl) return "OpenGL_ES OpenVG OpenGL ";
				if(      ovg && ogl) return "OpenVG OpenGL ";
				if(es &&        ogl) return "OpenGL_ES OpenGL ";
				if(es && ovg       ) return "OpenGL_ES OpenVG ";
				if(es              ) return "OpenGL_ES ";
				if(      ovg       ) return "OpenVG ";
				if(             ogl) return "OpenGL ";
				return " ";
			}
#else /* defined(API_MODULES_RUNTIME_CHECKED) */
			return
#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2)
				"OpenGL_ES "
#endif /* defined(SUPPORT_OPENGLES1)|| defined(SUPPORT_OPENGLES2) */

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)
				"OpenVG "
#endif /* defined(SUPPORT_OPENVG) */

#if defined(SUPPORT_OPENGL)
				"OpenGL "
#endif /* defined(SUPPORT_OPENGL) */

				;
#endif /* defined(API_MODULES_RUNTIME_CHECKED) */
		}
		default:
		{
			psTls->lastError = EGL_BAD_PARAMETER;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryString);

			return IMG_NULL;
		}
	}
}

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
IMG_INTERNAL EGLBoolean IMGeglHibernateProcessIMG(void)
{
	TLS				psTls;
	SrvSysContext	*psSysContext;
	KEGL_DISPLAY	*psDisplay;

	psTls = TLS_Open(_TlsInit);
	if (psTls == IMG_NULL)
	{
		return EGL_FALSE;
	}

	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		/* Already hibernated, nothing todo. */
		return EGL_TRUE;
	}

	psDisplay = psTls->psGlobalData->asDisplay;

	psTls->lastError = EGL_SUCCESS;

	EGLThreadLock(psTls);
	{
		IMG_UINT32 ui32Slot;
		/* validate no context is current */
		for (ui32Slot = 0; ui32Slot < EGL_MAX_NUM_DISPLAYS; ui32Slot++)
		{
			/* is display initialized? */
			if (psDisplay[ui32Slot].isInitialised != EGL_FALSE)
			{
				/* is window system module present? */
				if (psDisplay[ui32Slot].pWSEGL_FT)
				{
					KEGL_CONTEXT *psContext;
					for (psContext = psDisplay[ui32Slot].psHeadContext; psContext!=IMG_NULL;
						 psContext = psContext->psNextContext)
					{
						if (psContext->isCurrent)
						{
							psTls->lastError = EGL_BAD_CONTEXT;
							return EGL_FALSE;
						}
					}
				}
			}
		}

		/* hibernate all surfaces */
		{
			EGLRenderSurface *psSurface;
			SrvSysContext *psSysContext = &psTls->psGlobalData->sSysContext;
			for (
				psSurface = psSysContext->psHeadSurface; 
				psSurface != IMG_NULL; 
				psSurface = psSurface->psNextSurfaceAll
			)
			{
				KEGLHibernateRenderSurface(psSysContext, psSurface);
			}
			psSysContext->bHibernated = IMG_TRUE;
		}
	}
	EGLThreadUnlock(psTls);

	if(SGXDestroyRenderContext(&psSysContext->s3D,
							   psSysContext->hRenderContext,
							   psSysContext->psVisTestResults,
							   CLEANUP_WITH_POLL) != PVRSRV_OK)
	{
	    PVR_DPF((PVR_DBG_ERROR,"Couldn't destroy render context"));
	}
	psSysContext->hRenderContext = (IMG_HANDLE)0;

	return EGL_TRUE;
}

IMG_INTERNAL EGLBoolean IMGeglAwakenProcessIMG(void)
{
	TLS				psTls;
	SrvSysContext	*psSysContext;

	psTls = TLS_Open(_TlsInit);
	if (psTls == IMG_NULL)
	{
		return EGL_FALSE;
	}

	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_FALSE)
	{
		/* Already awake, nothing todo. */
		return EGL_TRUE;
	}

	psTls->lastError = EGL_SUCCESS;

	if(SGXCreateRenderContext(	&psSysContext->s3D,
								&psSysContext->sRenderContext,
								&psSysContext->hRenderContext,
								&psSysContext->psVisTestResults) != PVRSRV_OK)
	{
		return EGL_FALSE;
	}

	/* there is no locking around this code */
	{
		/* awaken all surfaces */
		{
			EGLRenderSurface	*psSurface;
			SrvSysContext		*psSysContext = &psTls->psGlobalData->sSysContext;

			for (psSurface = psSysContext->psHeadSurface; psSurface != IMG_NULL; psSurface = psSurface->psNextSurfaceAll)
			{
				KEGLAwakeRenderSurface(psSysContext, psSurface);
			}
			psSysContext->bHibernated = IMG_FALSE;
		}
	}

	return EGL_TRUE;
}
#endif /* defined(EGL_EXTENSION_IMG_EGL_HIBERNATION) */


/***********************************************************************
 *
 *  FUNCTION   : eglGetProcAddress
 *  PURPOSE    : Retrieve extension functions.
 *               No extension functions are currently implemented.
 *  PARAMETERS : In:  procname - Extension function name.
 *  RETURNS    : Extension function or IMG_NULL.
 *
 **********************************************************************/
IMG_EXPORT void (IMG_CALLCONV * IMGeglGetProcAddress(const char *procname))(void)
{
	TLS			psTls;
	EGLint		uIndex;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	/* This table defines the procedures which can be queried and the
	 * associated function */
	static const struct
	{
		const char  *pProcname;
		EGL_PROC    pfnProc;
	} aProcedure[] =
	{
#if defined(EGL_EXTENSION_KHR_IMAGE)
		  {"eglCreateImageKHR",             (EGL_PROC)IMGeglCreateImageKHR},
		  {"eglDestroyImageKHR",            (EGL_PROC)IMGeglDestroyImageKHR},
#endif /* defined(EGL_EXTENSION_KHR_IMAGE) */
#if defined(EGL_EXTENSION_KHR_FENCE_SYNC) || defined(EGL_EXTENSION_KHR_REUSABLE_SYNC)
		  {"eglCreateSyncKHR",              (EGL_PROC)IMGeglCreateSyncKHR},
		  {"eglDestroySyncKHR",             (EGL_PROC)IMGeglDestroySyncKHR},
		  {"eglClientWaitSyncKHR",          (EGL_PROC)IMGeglClientWaitSyncKHR},
#if defined(EGL_EXTENSION_KHR_REUSABLE_SYNC)
		  {"eglSignalSyncKHR",              (EGL_PROC)IMGeglSignalSyncKHR},
#endif /* defined(EGL_EXTENSION_KHR_REUSABLE_SYNC) */
		  {"eglGetSyncAttribKHR",           (EGL_PROC)IMGeglGetSyncAttribKHR},
#endif /* defined(EGL_EXTENSION_KHR_FENCE_SYNC) || defined(EGL_EXTENSION_KHR_REUSABLE_SYNC) */
#if defined(EGL_EXTENSION_NOK_IMAGE_SHARED)
		  {"eglCreateSharedImageNOK",       (EGL_PROC)IMGeglCreateSharedImageNOK},
		  {"eglDestroySharedImageNOK",      (EGL_PROC)IMGeglDestroySharedImageNOK},
		  {"eglQueryImageNOK",              (EGL_PROC)IMGeglQueryImageNOK},
#endif
#if defined(EGL_EXTENSION_ANDROID_BLOB_CACHE)
		  {"eglSetBlobCacheFuncsANDROID",   (EGL_PROC)IMGeglSetBlobCacheFuncsANDROID},
#endif
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
		  {"eglHibernateProcessIMG",        (EGL_PROC)IMGeglHibernateProcessIMG},
		  {"eglAwakenProcessIMG",           (EGL_PROC)IMGeglAwakenProcessIMG},
#endif
		  {0,0}
	  };

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglGetProcAddress (%s)", procname));

	psTls = TLS_Open(_TlsInit);
	if (psTls==IMG_NULL)
	{
		return IMG_NULL;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglGetProcAddress);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

		return EGL_FALSE;
	}
#endif

	if (procname==IMG_NULL)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);
		return IMG_NULL;
	}

	/* Check the table of procedures aProcedure, for a match, if found
	   return the associated function pointer. */
	for (uIndex=0; aProcedure[uIndex].pProcname!=0; uIndex++)
	{
		if (sceClibStrncmp(aProcedure[uIndex].pProcname,
					procname,
					sceClibStrnlen(aProcedure[uIndex].pProcname, 256)+1) == 0)
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

			return aProcedure[uIndex].pfnProc;
		}
	}

#	if defined(API_MODULES_RUNTIME_CHECKED)
	{
		/* IMGFindLibraryToLoad() will not return library to load that is not available. */
		switch(IMGFindLibraryToLoad(procname))
		{
			/* wrong name - extension not found */
			case(IMGEGL_NO_LIBRARY):
			{
				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				/* TODO Should we try to load OGL if no functions present? */ 
				if(
					psTls->psGlobalData->bHaveOGLFunctions && 
					psTls->psGlobalData->spfnOGL.pfnGLGetProcAddress
				)
				{
					return psTls->psGlobalData->spfnOGL.pfnGLGetProcAddress(procname);
				}
				return IMG_NULL;
			}

			/* name clash - use dummy function  */
			case(IMGEGL_NAME_CLASH):
			{
				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return IMGGetDummyFunction(procname);
			}

			/* extension is in GLES1 module - load it */
			case(IMGEGL_LOAD_GLES1):
			{
				if(!psTls->psGlobalData->bHaveOGLES1Functions)
				{
					if (!LoadOGLES1AndGetFunctions(psTls->psGlobalData))
					{
						psTls->lastError = EGL_NOT_INITIALIZED;
						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);
						return IMG_NULL;
					}
				}

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return psTls->psGlobalData->spfnOGLES1.pfnGLESGetProcAddress(procname);
			}

			/* extension is in GLES2 module - load it */
			case(IMGEGL_LOAD_GLES2):
			{
				if(!psTls->psGlobalData->bHaveOGLES2Functions)
				{
					if (!LoadOGLES2AndGetFunctions(psTls->psGlobalData))
					{
						psTls->lastError = EGL_NOT_INITIALIZED;

						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

						return IMG_NULL;
					}
				}

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return psTls->psGlobalData->spfnOGLES2.pfnGLESGetProcAddress(procname);
			}

			/* extension is in GLES2 module - load it */
			case(IMGEGL_LOAD_OPENVG):
			{
				if(!psTls->psGlobalData->bHaveOVGFunctions)
				{
					if (!LoadOVGAndGetFunctions(psTls->psGlobalData))
					{
						psTls->lastError = EGL_NOT_INITIALIZED;

						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

						return IMG_NULL;
					}
				}

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return psTls->psGlobalData->spfnOVG.pfnOVGGetProcAddress(procname);
			}

			default:
			{
				PVR_DPF((PVR_DBG_WARNING,"IMGeglGetProcAddress: Invalid load library request"));

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return IMG_NULL;
			}
		}
	}
#	else /* defined(API_MODULES_RUNTIME_CHECKED) */
	{
		switch(IMGFindLibraryToLoad(procname))
		{
			/* wrong name - extension not found */
			case(IMGEGL_NO_LIBRARY):
			{
				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

#if defined(SUPPORT_OPENGL)
				if(psTls->psGlobalData->bHaveOGLFunctions && psTls->psGlobalData->spfnOGL.pfnGLGetProcAddress)
				{
					return psTls->psGlobalData->spfnOGL.pfnGLGetProcAddress(procname);
				}
#endif
				return IMG_NULL;
			}

#if defined(SUPPORT_OPENGLES1) && defined(SUPPORT_OPENGLES2)
			/* name clash - use dummy function  */
			case(IMGEGL_NAME_CLASH):
			{
				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return IMGGetDummyFunction(procname);
			}
#endif

#if defined(SUPPORT_OPENGLES1)
			/* extension is in GLES1 module - load it */
			case(IMGEGL_LOAD_GLES1):
			{
				if(!psTls->psGlobalData->bHaveOGLES1Functions)
				{
					if (!LoadOGLES1AndGetFunctions(psTls->psGlobalData))
					{
						psTls->lastError = EGL_NOT_INITIALIZED;
						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);
						return IMG_NULL;
					}
				}

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return psTls->psGlobalData->spfnOGLES1.pfnGLESGetProcAddress(procname);
			}
#endif

#if defined(SUPPORT_OPENGLES2)
			/* extension is in GLES2 module - load it */
			case(IMGEGL_LOAD_GLES2):
			{
				if(!psTls->psGlobalData->bHaveOGLES2Functions)
				{
					if (!LoadOGLES2AndGetFunctions(psTls->psGlobalData))
					{
						psTls->lastError = EGL_NOT_INITIALIZED;

						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

						return IMG_NULL;
					}
				}

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return psTls->psGlobalData->spfnOGLES2.pfnGLESGetProcAddress(procname);
			}
#endif

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)
			/* extension is in GLES2 module - load it */
			case(IMGEGL_LOAD_OPENVG):
			{
				if(!psTls->psGlobalData->bHaveOVGFunctions)
				{
					if (!LoadOVGAndGetFunctions(psTls->psGlobalData))
					{
						psTls->lastError = EGL_NOT_INITIALIZED;

						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

						return IMG_NULL;
					}
				}

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return psTls->psGlobalData->spfnOVG.pfnOVGGetProcAddress(procname);
			}
#endif

			/* here handle other libraries - e.g., openvg, etc... */

			default:
			{
				PVR_DPF((PVR_DBG_WARNING,"IMGeglGetProcAddress: Invalid load library request"));

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetProcAddress);

				return IMG_NULL;
			}
		}
	}
#	endif /* defined(API_MODULES_RUNTIME_CHECKED) */
}


/***********************************************************************
 *
 *  FUNCTION   : eglGetConfigs
 *  PURPOSE    : Retreive the configurations associated with a display.
 *  PARAMETERS : In:  eglDpy - Display.
 *               Out: configs - Receives the config array.
 *               In:  config_size - The size of the config array.
 *               Out: num_config - Receives the actual number of configs
 *                    received.
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglGetConfigs(EGLDisplay eglDpy, EGLConfig *configs,
									   EGLint config_size, EGLint *num_config)
{
	KEGL_DISPLAY	*psDpy;
	TLS				psTls;
	EGLint			index;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglGetConfigs"));

	psTls = TLS_Open(_TlsInit);
	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglGetConfigs);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigs);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigs);
		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);
	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigs);
		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];
	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigs);
		return EGL_FALSE;
	}

	if (num_config==0)
	{
		psTls->lastError = EGL_BAD_PARAMETER;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigs);
		return EGL_FALSE;
	}

	if (configs==0)
	{
		*num_config = CFG_Variants(psDpy);
	}
	else
	{
		EGLint count = CFG_Variants(psDpy);
		EGLint num_config_local;

		for (
			num_config_local=0;
			num_config_local < count && num_config_local < config_size;
			num_config_local++
		)
		{
			configs[num_config_local] = (EGLConfig )(num_config_local+1);
		}

		*num_config = num_config_local;
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigs);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglChooseConfig
 *  PURPOSE    : Retrieve configurations which match a selection criteria.
 *  PARAMETERS : In:  dpy - Display.
 *               In:  pAttribList -
 *                    List of required attribute identifiers and
 *                    attribute values, terminated with identifier
 *                    EGL_NONE.
 *               Out: configs - Receives the config array.
 *               In:  config_size - The size of the config array.
 *               Out: num_config - Receives the actual number of configs
 *                    received.
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglChooseConfig(EGLDisplay eglDpy,
										 const EGLint *pAttribList,
										 EGLConfig *configs,
										 EGLint config_size,
										 EGLint *num_config)
{
	KEGL_DISPLAY	*psDpy;
	KEGL_CONFIG		**working_configs;
	EGLint			match_count;
	EGLint			attriblist_count;
	EGLint			i, index;
	EGLint			cfg_variants;
	KEGL_CONFIG		*requested_cfg;
	EGLint			num_config_local;
	TLS				psTls;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif


	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglChooseConfig"));

	psTls = TLS_Open(_TlsInit);
	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglChooseConfig);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);
		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);
	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);
		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];
	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);
		return EGL_FALSE;
	}

	if (num_config==0)
	{
		psTls->lastError = EGL_BAD_PARAMETER;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);
		return EGL_FALSE;
	}

	psTls->lastError = _ValidateAttribList(pAttribList, &attriblist_count);
	if (psTls->lastError != EGL_SUCCESS)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);
		return EGL_FALSE;
	}

	requested_cfg = CFG_PrepareConfigFilter(pAttribList, attriblist_count);

	if (requested_cfg==IMG_NULL)
	{
		psTls->lastError = EGL_BAD_ATTRIBUTE;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);
		return EGL_FALSE;
	}

	cfg_variants = CFG_Variants(psDpy);

	working_configs = EGLCalloc(sizeof(*working_configs) * cfg_variants);
	if (working_configs==IMG_NULL)
	{
		CFGC_Unlink(requested_cfg);
		psTls->lastError = EGL_BAD_ALLOC;
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);
		return EGL_FALSE;
	}

	for (match_count=0,i=1; i<=cfg_variants; i++)
	{
		KEGL_CONFIG *psCfg;

		psTls->lastError = CFG_GenerateVariant(psDpy, i, &psCfg);

		if (psTls->lastError!=EGL_SUCCESS)
		{
			for (i=0; i<match_count; i++)
			{
				CFGC_Unlink(working_configs[i]);
			}

			EGLFree(working_configs);

			CFGC_Unlink(requested_cfg);

			psTls->lastError = EGL_BAD_ALLOC;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);

			return EGL_FALSE;
		}

		if (CFG_Match(requested_cfg, psCfg))
		{
			working_configs[match_count] = psCfg;

			match_count ++;
		}
		else
		{
			CFGC_Unlink(psCfg);
		}
	}

	if (configs==0)
	{
		for (i=0; i<match_count; i++)
		{
			CFGC_Unlink(working_configs[i]);
		}

		EGLFree(working_configs);

		CFGC_Unlink(requested_cfg);

		*num_config = match_count;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);

		return EGL_TRUE;
	}

	/* sort the results */
	PVR_qsort_s(working_configs, match_count, sizeof(*working_configs),
				CFG_Compare, requested_cfg);

	CFGC_Unlink(requested_cfg);

	for (num_config_local=0;
		 num_config_local<config_size && num_config_local < match_count;
		 num_config_local++)
	{
		configs[num_config_local] = (EGLConfig) CFGC_GetAttrib(working_configs[num_config_local], EGL_CONFIG_ID);

		CFGC_Unlink(working_configs[num_config_local]);
	}

	/* Write back the number of configs written */
	*num_config = num_config_local;

	/* Mop up any allocated but unrequired configs */
	for (;num_config_local < match_count; num_config_local++)
	{
		CFGC_Unlink(working_configs[num_config_local]);
	}

	EGLFree(working_configs);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglChooseConfig);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglGetConfigAttrib
 *  PURPOSE    : Retreive an attribute from a configuration.
 *  PARAMETERS : In:  eglDpy
 *               In:  config
 *               In:  attribute
 *               Out: value
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglGetConfigAttrib(EGLDisplay eglDpy,
											EGLConfig eglCfg,
											EGLint attribute,
											EGLint *value)
{
	KEGL_DISPLAY *psDpy;
	KEGL_CONFIG *psCfg;
	TLS psTls;
	EGLint index;
	KEGL_CONFIG_INDEX configIndex= (KEGL_CONFIG_INDEX)eglCfg;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglGetConfigAttrib"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglGetConfigAttrib);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigAttrib);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigAttrib);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigAttrib);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigAttrib);

		return EGL_FALSE;
	}

	if (value==IMG_NULL)
	{
		psTls->lastError = EGL_BAD_PARAMETER;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigAttrib);

		return EGL_FALSE;
	}

	if ((attribute<_EGL_CONFIG_ATTR_FIRST) || (attribute >_EGL_CONFIG_ATTR_LAST) || (attribute == EGL_NONE))
	{

		/* Check for special attributes (extensions) outside this range */

		switch(attribute)
		{
#if defined(EGL_EXTENSION_ANDROID_RECORDABLE)
			case EGL_RECORDABLE_ANDROID: break;
#endif
			default:
			{
				psTls->lastError = EGL_BAD_ATTRIBUTE;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigAttrib);

				return EGL_FALSE;
			}
		}
	}

	psTls->lastError = CFG_GenerateVariant(psDpy, configIndex, &psCfg);

	if (psTls->lastError!=EGL_SUCCESS)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigAttrib);

		return EGL_FALSE;
	}

	*value = CFGC_GetAttrib(psCfg, attribute);

	CFGC_Unlink(psCfg);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetConfigAttrib);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   :  eglCreateWindowSurface
 *  PURPOSE    :  Create a window surface.
 *  PARAMETERS :  In:  eglDpy -
 *                In:  config -
 *                In:  window -
 *                In:  pAttribList -
 *  RETURNS    :  Created surface or EGL_NO_SURFACE.
 *
 **********************************************************************/
IMG_EXPORT EGLSurface IMGeglCreateWindowSurface(EGLDisplay eglDpy,
												EGLConfig eglCfg,
												NativeWindowType window,
												const EGLint *pAttribList)
{
	WSEGLError eError;
	KEGL_DISPLAY *psDpy;
	KEGL_SURFACE *psSurface;
	TLS psTls;
	EGLint index, value;
	PVRSRV_ALPHA_FORMAT			eAlphaFormat = PVRSRV_ALPHA_FORMAT_NONPRE; /* Default */
	PVRSRV_COLOURSPACE_FORMAT	eColourSpaceFormat = PVRSRV_COLOURSPACE_FORMAT_NONLINEAR;
	KEGL_CONFIG_INDEX configIndex= (KEGL_CONFIG_INDEX)eglCfg;
	Psp2NativeWindow *psIntWindows;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION) || defined(__psp2__)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglCreateWindowSurface"));

	IMGeglGetConfigAttrib(eglDpy, eglCfg, EGL_DEPTH_SIZE, &value);
	/* 16 bit custom config picked */
	if( value == 16 )
	{
		PVR_DPF((PVR_DBG_WARNING, "IMGeglCreateWindowSurface: Using custom HW EGL config with EGL_DEPTH_SIZE=16"));
	}

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglCreateWindowSurface);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION) || defined(__psp2__)
	psSysContext = &psTls->psGlobalData->sSysContext;
#endif
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateWindowSurface);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateWindowSurface);

		return EGL_NO_SURFACE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateWindowSurface);

		return EGL_NO_SURFACE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateWindowSurface);

		return EGL_NO_SURFACE;
	}


	if (pAttribList!=IMG_NULL)
	{
		while (*pAttribList!=EGL_NONE)
		{
			EGLint attrib = *pAttribList++;
			EGLint value;

			value = *pAttribList++;

			switch (attrib)
			{
				case EGL_ALPHA_FORMAT:
				{
					switch(value)
					{
						case EGL_ALPHA_FORMAT_NONPRE:
						{
							eAlphaFormat = PVRSRV_ALPHA_FORMAT_NONPRE;

							break;
						}
						case EGL_ALPHA_FORMAT_PRE:
						{
							eAlphaFormat = PVRSRV_ALPHA_FORMAT_PRE;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}

					break;
				}
				case EGL_COLORSPACE:
				{
					switch(value)
					{
						case EGL_COLORSPACE_LINEAR:
						{
							eColourSpaceFormat = PVRSRV_COLOURSPACE_FORMAT_LINEAR;

							break;
						}
						case EGL_COLORSPACE_sRGB:
						{
							eColourSpaceFormat = PVRSRV_COLOURSPACE_FORMAT_NONLINEAR;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}
					break;
				}
				case EGL_RENDER_BUFFER:
				{
					switch(value)
					{
						case EGL_BACK_BUFFER:
						case EGL_SINGLE_BUFFER:
						{
							/*
								Implementations that do not support single-buffered
								rendering may ignore this setting.
							*/
							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}
					break;
				}
				default:
				{
bad_attrib:
					psTls->lastError = EGL_BAD_ATTRIBUTE;

					IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateWindowSurface);

					return EGL_NO_SURFACE;
				}
			}
		}
	}

	if  (_FindWindowSurface(psDpy, window)!=IMG_NULL)
	{
		psTls->lastError = EGL_BAD_ALLOC;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateWindowSurface);

		return EGL_NO_SURFACE;
	}

	psSurface = EGLCalloc(sizeof(KEGL_SURFACE));

	// Default PSP2 config
	if (window == IMG_NULL)
	{
		window = EGLCalloc(sizeof(Psp2NativeWindow));

		window->type = PSP2_DRAWABLE_TYPE_WINDOW;
		window->windowSize = PSP2_WINDOW_960X544;
		window->numFlipBuffers = 2;
		window->flipChainThrdAffinity = 0;
	}
	else
	{
		psIntWindows = EGLCalloc(sizeof(Psp2NativeWindow));
		PVRSRVMemCopy(psIntWindows, window, sizeof(Psp2NativeWindow));
		window = psIntWindows;
	}

	window->hDevMemContext = psSysContext->hDevMemContext;
	window->psDevData = &psSysContext->s3D;
	window->swapInterval = 1;

	if (psSurface == 0)
	{
		psTls->lastError = EGL_BAD_ALLOC;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateWindowSurface);

		return EGL_NO_SURFACE;
	}

	psSurface->isDeleting = EGL_FALSE;
	psSurface->type = EGL_SURFACE_WINDOW;
	psSurface->u.window.native = window;
	psSurface->iMultiSampleResolve = EGL_MULTISAMPLE_RESOLVE_DEFAULT;
	psSurface->iSwapBehaviour = EGL_BUFFER_PRESERVED;

	/* Sanity checks: Should be zeroed by Calloc */
	PVR_ASSERT(psSurface->currentCount == 0);
	PVR_ASSERT(psSurface->refCount == 0);
	PVR_ASSERT(psSurface->boundThread == 0);
	PVR_ASSERT(psSurface->u.window.ui32SwapCount == 0);
	psSurface->psDpy = psDpy;

	psTls->lastError = CFG_GenerateVariant(psDpy, configIndex, &psSurface->psCfg);

	if (psTls->lastError!=EGL_SUCCESS)
	{
		goto cleanup_exit;
	}

	if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_WINDOW_BIT))
	{
		psTls->lastError = EGL_BAD_MATCH;

		goto cleanup_exit;
	}
	/* No need to check for non-linear as there is no bit in the config for this - it is assumed to always
	 * be available
	 */
	if(eColourSpaceFormat == PVRSRV_COLOURSPACE_FORMAT_LINEAR)
	{
		if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_VG_COLORSPACE_LINEAR_BIT))
		{
			psTls->lastError = EGL_BAD_MATCH;

			goto cleanup_exit;
		}
	}

	/* No need to check for non-pre as there is no bit in the config for this - it is assumed to always
	 * be available
	 */
	if(eAlphaFormat == PVRSRV_ALPHA_FORMAT_PRE)
	{
		if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_VG_ALPHA_FORMAT_PRE_BIT))
		{
			psTls->lastError = EGL_BAD_MATCH;

			goto cleanup_exit;
		}
	}

	psSurface->u.window.sConfig.ui32DrawableType = WSEGL_DRAWABLE_WINDOW;

	psSurface->u.window.sConfig.ePixelFormat = aConvertPVRPixelFormatToWSEGL[CFGC_GetPixelFormat(psSurface->psCfg)];
	psSurface->u.window.sConfig.ulNativeVisualID = CFGC_GetAttrib(psSurface->psCfg, EGL_NATIVE_VISUAL_ID);

	EGLThreadLockWSEGL(psDpy, psTls);

	eError = psDpy->pWSEGL_FT->pfnWSEGL_CreateWindowDrawable(psDpy->hDisplay, &psSurface->u.window.sConfig,
												 &psSurface->u.window.hDrawable, window, &psSurface->eRotationAngle, psSysContext->psConnection);

	EGLThreadUnlockWSEGL(psDpy, psTls);

	switch (eError)
	{
		case WSEGL_SUCCESS:
		{
			if(!SRV_CreateSurface(&psTls->psGlobalData->sSysContext, psSurface))
			{

				EGLThreadLockWSEGL(psDpy, psTls);

				psSurface->psDpy->pWSEGL_FT->pfnWSEGL_DeleteDrawable(psSurface->u.window.hDrawable);

				EGLThreadUnlockWSEGL(psDpy, psTls);

				psTls->lastError = EGL_BAD_ALLOC;

				break;
			}

			psSurface->sRenderSurface.eAlphaFormat = eAlphaFormat;
			psSurface->sRenderSurface.eColourSpace = eColourSpaceFormat;

			EGLThreadLock(psTls);

			psTls->lastError = EGL_SUCCESS;

			/* Chain the new surface onto the displays surface list */
			psSurface->psNextSurface = psDpy->psHeadSurface;
			psDpy->psHeadSurface = psSurface;

			EGLThreadUnlock(psTls);

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateWindowSurface);

			return psSurface;
		}
		case WSEGL_BAD_MATCH:
		{
			psTls->lastError = EGL_BAD_MATCH;

			break;
		}
		case WSEGL_BAD_NATIVE_WINDOW:
		{
			psTls->lastError = EGL_BAD_NATIVE_WINDOW;

			break;
		}
		case WSEGL_OUT_OF_MEMORY:
		{
			psTls->lastError = EGL_BAD_ALLOC;

			break;
		}
		default:
		{
			psTls->lastError = EGL_NOT_INITIALIZED;

			break;
		}
	}


cleanup_exit:

	CFGC_Unlink(psSurface->psCfg); /* CFGC_Unlink does the null check */

	EGLFree(psSurface);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateWindowSurface);

	return EGL_NO_SURFACE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglCreatePixmapSurface
 *  PURPOSE    : Create a pixmap surface.
 *               There are no attributes defined for pAttribList is the
 *               current implementation.
 *  PARAMETERS : In:  eglDpy - Display
 *               In:  eglCfg - Configuration.
 *               In:  pixmap - Native pixmap.
 *               In:  pAttribList - List of required attributes.
 *  RETURNS    : Created surface or EGL_NO_SURFACE.
 *
 **********************************************************************/
IMG_EXPORT EGLSurface IMGeglCreatePixmapSurface(EGLDisplay eglDpy,
													  EGLConfig eglCfg,
													  NativePixmapType pixmap,
													  const EGLint *pAttribList)
{
	WSEGLError eError;
	KEGL_DISPLAY *psDpy;
	KEGL_SURFACE *psSurface;
	TLS psTls;
	EGLint index;
	KEGL_CONFIG_INDEX configIndex= (KEGL_CONFIG_INDEX)eglCfg;
	PVRSRV_ALPHA_FORMAT			eAlphaFormat = PVRSRV_ALPHA_FORMAT_NONPRE; /* Default */
	PVRSRV_COLOURSPACE_FORMAT	eColourSpaceFormat = PVRSRV_COLOURSPACE_FORMAT_NONLINEAR;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglCreatePixmapSurface"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

		return EGL_NO_SURFACE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

		return EGL_NO_SURFACE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

		return EGL_NO_SURFACE;
	}

	if (pAttribList!=IMG_NULL)
	{
		while (*pAttribList!=EGL_NONE)
		{
			EGLint attrib = *pAttribList++;
			EGLint value;

			value = *pAttribList++;

			switch (attrib)
			{
				case EGL_ALPHA_FORMAT:
				{
					switch(value)
					{
						case EGL_ALPHA_FORMAT_NONPRE:
						{
							eAlphaFormat = PVRSRV_ALPHA_FORMAT_NONPRE;

							break;
						}
						case EGL_ALPHA_FORMAT_PRE:
						{
							eAlphaFormat = PVRSRV_ALPHA_FORMAT_PRE;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}

					break;
				}
				case EGL_COLORSPACE:
				{
					switch(value)
					{
						case EGL_COLORSPACE_LINEAR:
						{
							eColourSpaceFormat = PVRSRV_COLOURSPACE_FORMAT_LINEAR;

							break;
						}
						case EGL_COLORSPACE_sRGB:
						{
							eColourSpaceFormat = PVRSRV_COLOURSPACE_FORMAT_NONLINEAR;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}
					break;
				}
				case EGL_RENDER_BUFFER:
				{
					switch(value)
					{
						case EGL_BACK_BUFFER:
						case EGL_SINGLE_BUFFER:
						{
							/*
								Implementations that do not support single-buffered
								rendering may ignore this setting.
							*/
							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}
					break;
				}
				default:
				{
bad_attrib:
					psTls->lastError = EGL_BAD_ATTRIBUTE;

					IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

					return EGL_NO_SURFACE;
				}
			}
		}
	}

	/*
		Check to see if this pixmap is already associated with a surface on
		this display
	*/
	if (_FindPixmapSurface(psDpy, pixmap))
	{
		psTls->lastError = EGL_BAD_ALLOC;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

		return EGL_NO_SURFACE;
	}

	psSurface = EGLCalloc(sizeof *psSurface);

	if (psSurface == 0)
	{
		psTls->lastError = EGL_BAD_ALLOC;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

		return EGL_NO_SURFACE;
	}

	/* Sanity checks: Should be zeroed by Calloc */
	PVR_ASSERT(psSurface->currentCount == 0);
	PVR_ASSERT(psSurface->refCount == 0);
	PVR_ASSERT(psSurface->boundThread == 0);

	psSurface->isDeleting = EGL_FALSE;
	psSurface->type = EGL_SURFACE_PIXMAP;
	psSurface->u.pixmap.native = pixmap;
	psSurface->psDpy = psDpy;

	psTls->lastError = CFG_GenerateVariant(psDpy, configIndex, &psSurface->psCfg);

	if (psTls->lastError!=EGL_SUCCESS)
	{
		goto cleanup_exit;
	}

	if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_PIXMAP_BIT))
	{
		psTls->lastError = EGL_BAD_MATCH;

		goto cleanup_exit;
	}

	/* No need to check for non-linear as there is no bit in the config for this - it is assumed to always
	 * be available
	 */
	if(eColourSpaceFormat == PVRSRV_COLOURSPACE_FORMAT_LINEAR)
	{
		if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_VG_COLORSPACE_LINEAR_BIT))
		{
			psTls->lastError = EGL_BAD_MATCH;

			goto cleanup_exit;
		}
	}

	/* No need to check for non-pre as there is no bit in the config for this - it is assumed to always
	 * be available
	 */
	if(eAlphaFormat == PVRSRV_ALPHA_FORMAT_PRE)
	{
		if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_VG_ALPHA_FORMAT_PRE_BIT))
		{
			psTls->lastError = EGL_BAD_MATCH;

			goto cleanup_exit;
		}
	}


	psSurface->u.pixmap.sConfig.ui32DrawableType		= WSEGL_DRAWABLE_PIXMAP;

	psSurface->u.pixmap.sConfig.ePixelFormat = aConvertPVRPixelFormatToWSEGL[CFGC_GetPixelFormat(psSurface->psCfg)];

	EGLThreadLockWSEGL(psDpy, psTls);

	eError = psDpy->pWSEGL_FT->pfnWSEGL_CreatePixmapDrawable(psDpy->hDisplay, &psSurface->u.pixmap.sConfig,
												 &psSurface->u.pixmap.hDrawable, pixmap, &psSurface->eRotationAngle);

	EGLThreadUnlockWSEGL(psDpy, psTls);

	switch (eError)
	{
		case WSEGL_SUCCESS:
		{
			if(!SRV_CreateSurface(&psTls->psGlobalData->sSysContext, psSurface))
			{
				EGLThreadLockWSEGL(psDpy, psTls);

				psSurface->psDpy->pWSEGL_FT->pfnWSEGL_DeleteDrawable(psSurface->u.pixmap.hDrawable);

				EGLThreadUnlockWSEGL(psDpy, psTls);

				psTls->lastError = EGL_BAD_ALLOC;

				break;
			}

			psSurface->sRenderSurface.eAlphaFormat = eAlphaFormat;
			psSurface->sRenderSurface.eColourSpace = eColourSpaceFormat;

			psTls->lastError = EGL_SUCCESS;

			EGLThreadLock(psTls);

			/* Chain the new surface onto the displays surface list */
			psSurface->psNextSurface = psDpy->psHeadSurface;

			psDpy->psHeadSurface = psSurface;

			EGLThreadUnlock(psTls);

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

			return psSurface;
		}
		case WSEGL_BAD_NATIVE_PIXMAP:
		{
			psTls->lastError = EGL_BAD_NATIVE_PIXMAP;

			break;
		}
		case  WSEGL_BAD_MATCH:
		{
			psTls->lastError = EGL_BAD_MATCH;

			break;
		}
		case WSEGL_OUT_OF_MEMORY:
		{
			psTls->lastError = EGL_BAD_ALLOC;

			break;
		}
		default:
		{
			psTls->lastError = EGL_NOT_INITIALIZED;

			break;
		}
	}

cleanup_exit:

	CFGC_Unlink(psSurface->psCfg); /* CFGC_Unlink does the null check */

	EGLFree(psSurface);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePixmapSurface);

	return EGL_NO_SURFACE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglCreatePbufferSurface
 *  PURPOSE    : Create a Pbuffer surface.
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  eglCfg - Configuration.
 *               In:  pAttribList - Required attributes.
 *  RETURNS    : Created surface or EGL_NO_SURFACE.
 *
 **********************************************************************/
IMG_EXPORT EGLSurface IMGeglCreatePbufferSurface(EGLDisplay eglDpy,
												 EGLConfig eglCfg,
												 const EGLint *pAttribList)
{
	KEGL_DISPLAY *psDpy;
	KEGL_SURFACE * psSurface = IMG_NULL;
	EGLint pbuffer_width = 0;
	EGLint pbuffer_height = 0;
	EGLBoolean pbuffer_largest = EGL_FALSE;
	EGLint pixel_width = 0;
	PVRSRV_PIXEL_FORMAT pvr_pf;
	TLS psTls;
	EGLint index;
	KEGL_CONFIG_INDEX configIndex= (KEGL_CONFIG_INDEX)eglCfg;

	PVRSRV_PIXEL_FORMAT eTextureFormat = PVRSRV_PIXEL_FORMAT_UNKNOWN;
	IMG_BOOL bMipMap = IMG_FALSE;
	IMG_UINT32 ui32Level = 0;
	IMG_BOOL bTextureTarget = IMG_FALSE;
	PVRSRV_ALPHA_FORMAT			eAlphaFormat = PVRSRV_ALPHA_FORMAT_NONPRE; /* Default */
	PVRSRV_COLOURSPACE_FORMAT	eColourSpaceFormat = PVRSRV_COLOURSPACE_FORMAT_NONLINEAR;

	IMG_UINT32 ui32WidthLog2 = 0, ui32HeightLog2 = 0;

	EGLint renderableBits = 0;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglCreatePbufferSurface"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglCreatePbufferSurface);

#if defined(API_MODULES_RUNTIME_CHECKED)
	renderableBits = EGL_OPENGL_ES_BIT|EGL_OPENGL_ES2_BIT;

	if (psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL])
	{
		renderableBits |= EGL_OPENGL_BIT;
	}
#else
#   if defined(SUPPORT_OPENGL)
	renderableBits = EGL_OPENGL_ES_BIT|EGL_OPENGL_BIT|EGL_OPENGL_ES2_BIT;
#   else
	renderableBits = EGL_OPENGL_ES_BIT|EGL_OPENGL_ES2_BIT;
#   endif
#endif

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferSurface);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferSurface);

		return EGL_NO_SURFACE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferSurface);

		return EGL_NO_SURFACE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferSurface);

		return EGL_NO_SURFACE;
	}

	psSurface = EGLCalloc(sizeof *psSurface);

	if (psSurface == 0)
	{
		goto bad_alloc;
	}

	/* Sanity checks: Should be zeroed by Calloc */
	PVR_ASSERT(psSurface->currentCount == 0);
	PVR_ASSERT(psSurface->refCount == 0);
	PVR_ASSERT(psSurface->boundThread == 0);

	psSurface->isDeleting = EGL_FALSE;
	psSurface->type = EGL_SURFACE_PBUFFER;
	psSurface->psDpy = psDpy;

	psTls->lastError = CFG_GenerateVariant(psDpy, configIndex, &psSurface->psCfg);

	if (psTls->lastError!=EGL_SUCCESS)
	{
		goto cleanup_exit;
	}

	if (pAttribList!=IMG_NULL)
	{
		while (*pAttribList!=EGL_NONE)
		{
			EGLint attrib = *pAttribList++;
			EGLint value;

			value = *pAttribList++;

			switch (attrib)
			{
				case EGL_WIDTH:
				{
					pbuffer_width = value;

					break;
				}
				case EGL_HEIGHT:
				{
					pbuffer_height = value;

					break;
				}
				case EGL_LARGEST_PBUFFER:
				{
					pbuffer_largest = (value ? EGL_TRUE : EGL_FALSE);

					break;
				}
				case EGL_TEXTURE_TARGET:
				{
					/* Check the config supports OpenGL(ES) */
					if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_RENDERABLE_TYPE) & renderableBits))
					{
						goto bad_attrib;
					}

					switch(value)
					{
						case EGL_NO_TEXTURE:
						{
							bTextureTarget = IMG_FALSE;

							break;
						}
						case EGL_TEXTURE_2D:
						{
							bTextureTarget = IMG_TRUE;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}

					break;
				}
				case EGL_TEXTURE_FORMAT:
				{
					/* Check the config supports OpenGL(ES) */
					if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_RENDERABLE_TYPE) & renderableBits))
					{
						goto bad_attrib;
					}

					switch(value)
					{
						case EGL_NO_TEXTURE:
						{
							eTextureFormat = PVRSRV_PIXEL_FORMAT_UNKNOWN;

							break;
						}
						case EGL_TEXTURE_RGB:
						{
							eTextureFormat = PVRSRV_PIXEL_FORMAT_RGB565;

							break;
						}
						case EGL_TEXTURE_RGBA:
						{
							eTextureFormat = PVRSRV_PIXEL_FORMAT_ARGB8888;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}

					break;
				}
				case EGL_MIPMAP_TEXTURE:
				{
					/* Check the config supports OpenGL(ES) */
					if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_RENDERABLE_TYPE) & renderableBits))
					{
						goto bad_attrib;
					}

					switch(value)
					{
						case EGL_FALSE:
						{
							bMipMap = IMG_FALSE;

							break;
						}
						case EGL_TRUE:
						{
							bMipMap = IMG_TRUE;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}

					break;
				}
				case EGL_ALPHA_FORMAT:
				{
					switch(value)
					{
						case EGL_ALPHA_FORMAT_NONPRE:
						{
							eAlphaFormat = PVRSRV_ALPHA_FORMAT_NONPRE;

							break;
						}
						case EGL_ALPHA_FORMAT_PRE:
						{
							eAlphaFormat = PVRSRV_ALPHA_FORMAT_PRE;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}

					break;
				}
				case EGL_COLORSPACE:
				{
					switch(value)
					{
						case EGL_COLORSPACE_LINEAR:
						{
							eColourSpaceFormat = PVRSRV_COLOURSPACE_FORMAT_LINEAR;

							break;
						}
						case EGL_COLORSPACE_sRGB:
						{
							eColourSpaceFormat = PVRSRV_COLOURSPACE_FORMAT_NONLINEAR;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}
					break;
				}
				default:
				{
					goto bad_attrib;
				}
			}
		}
	}


	if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_PBUFFER_BIT))
	{
		goto bad_match;
	}

	if((eTextureFormat != PVRSRV_PIXEL_FORMAT_UNKNOWN) && !bTextureTarget)
	{
		goto bad_match;
	}

	if(bTextureTarget && (eTextureFormat == PVRSRV_PIXEL_FORMAT_UNKNOWN))
	{
		goto bad_match;
	}

	/* No need to check for non-linear as there is no bit in the config for this - it is assumed to always
	 * be available
	 */
	if(eColourSpaceFormat == PVRSRV_COLOURSPACE_FORMAT_LINEAR)
	{
		if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_VG_COLORSPACE_LINEAR_BIT))
		{
			goto bad_match;
		}
	}

	/* No need to check for non-pre as there is no bit in the config for this - it is assumed to always
	 * be available
	 */
	if(eAlphaFormat == PVRSRV_ALPHA_FORMAT_PRE)
	{
		if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_VG_ALPHA_FORMAT_PRE_BIT))
		{
			goto bad_match;
		}
	}

	if(eTextureFormat)
	{
		IMG_UINT32 ui32TexSize;

		EGLint oldWidth = pbuffer_width;
		EGLint oldHeight = pbuffer_height;

		if(eTextureFormat == PVRSRV_PIXEL_FORMAT_RGB565)
		{
			if (CFGC_GetAttrib(psSurface->psCfg, EGL_BIND_TO_TEXTURE_RGB) == IMG_FALSE)
			{
				goto bad_match;
			}
		}
		else
		{
			if (CFGC_GetAttrib(psSurface->psCfg, EGL_BIND_TO_TEXTURE_RGBA) == IMG_FALSE)
			{
				goto bad_match;
			}
		}

		/* We don't support mipmapped render targets */
		if(bMipMap)
		{
			goto bad_alloc;
		}

		ui32TexSize = 1;

		/* find the bounding texture sizes (power of 2) */
		while(ui32TexSize < (IMG_UINT32) pbuffer_width)
		{
			ui32TexSize <<= 1;
			ui32WidthLog2++;
		}

		if(!pbuffer_largest && (ui32TexSize != (IMG_UINT32)pbuffer_width))
		{
			goto bad_match;
		}
		else
		{
			if (ui32TexSize > (IMG_UINT32) pbuffer_width)
			{
				ui32TexSize >>= 1;
				ui32WidthLog2--;
			}

			pbuffer_width = (EGLint)ui32TexSize;
		}

		if(ui32WidthLog2 < IMG_MIN_RENDER_TEXTURE_LEVEL || ui32WidthLog2 > IMG_MAX_TEXTURE_MIPMAP_LEVELS)
		{
			goto bad_match;
		}

		ui32TexSize = 1;

		/* find the bounding texture sizes (power of 2) */
		while(ui32TexSize < (IMG_UINT32) pbuffer_height)
		{
			ui32TexSize <<= 1;
			ui32HeightLog2++;
		}

		if(!pbuffer_largest && (ui32TexSize != (IMG_UINT32)pbuffer_height))
		{
			goto bad_match;
		}
		else
		{
			if (ui32TexSize > (IMG_UINT32) pbuffer_height)
			{
				ui32TexSize >>= 1;
				ui32HeightLog2--;
			}

			pbuffer_height = (EGLint)ui32TexSize;
		}

		if(ui32HeightLog2 < IMG_MIN_RENDER_TEXTURE_LEVEL || ui32HeightLog2 > IMG_MAX_TEXTURE_MIPMAP_LEVELS)
		{
			goto bad_match;
		}

		if (oldWidth != pbuffer_width || oldHeight != pbuffer_height)
		{
			if ((IMG_FLOAT)oldWidth / (IMG_FLOAT)oldHeight - (IMG_FLOAT)pbuffer_width / (IMG_FLOAT)pbuffer_height != 0.0f)
			{
				goto bad_match;
			}
		}
	}

	psSurface->u.pbuffer.eTextureFormat = eTextureFormat;
	psSurface->u.pbuffer.bTexture = bTextureTarget;
	psSurface->u.pbuffer.bMipMap = bMipMap;
	psSurface->u.pbuffer.ui32Level = ui32Level;
	psSurface->u.pbuffer.bLargest = (IMG_BOOL)pbuffer_largest;

	if ((pbuffer_width < 0) ||
		(pbuffer_height < 0))
	{
		goto bad_parameter;
	}

	if ((pbuffer_width > CFGC_GetAttrib(psSurface->psCfg, EGL_MAX_PBUFFER_WIDTH)) ||
		(pbuffer_height > CFGC_GetAttrib(psSurface->psCfg, EGL_MAX_PBUFFER_HEIGHT)) ||
		(pbuffer_width * pbuffer_height > CFGC_GetAttrib(psSurface->psCfg, EGL_MAX_PBUFFER_PIXELS)))
	{
		goto bad_match;
	}

	pvr_pf = CFGC_GetPixelFormat(psSurface->psCfg);
	pixel_width = gasSRVPixelFormat[pvr_pf].iWidth >> 3;

	psSurface->sRenderSurface.eAlphaFormat = eAlphaFormat;
	psSurface->sRenderSurface.eColourSpace = eColourSpaceFormat;

	psTls->lastError = GWS_CreatePBufferDrawable(&psTls->psGlobalData->sSysContext,
												 psSurface,
												 pbuffer_width,
												 pbuffer_height,
												 pbuffer_largest,
												 pixel_width,
												 pvr_pf);
	if (psTls->lastError != EGL_SUCCESS)
	{
		goto cleanup_exit;
	}

	if (pbuffer_largest && eTextureFormat)
	{
		while((IMG_UINT32)pbuffer_width > psSurface->u.pbuffer.ui32PixelWidth)
		{
			pbuffer_width = (EGLint)(((IMG_UINT32)pbuffer_width) >> 1);
			ui32WidthLog2--;
		}

		while((IMG_UINT32)pbuffer_height > psSurface->u.pbuffer.ui32PixelHeight)
		{
			pbuffer_height = (EGLint)(((IMG_UINT32)pbuffer_height) >> 1);
			ui32HeightLog2--;
		}

		if (ui32WidthLog2 < IMG_MIN_RENDER_TEXTURE_LEVEL || ui32HeightLog2 < IMG_MIN_RENDER_TEXTURE_LEVEL)
		{
			goto bad_match;
		}
	}

	if(!SRV_CreateSurface(&psTls->psGlobalData->sSysContext, psSurface))
	{
		goto bad_alloc;
	}

	EGLThreadLock(psTls);

	/* chain this surface onto the displays surface list */
	psSurface->psNextSurface = psDpy->psHeadSurface;

	psDpy->psHeadSurface = psSurface;

	EGLThreadUnlock(psTls);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferSurface);

	return psSurface;


bad_alloc:
	psTls->lastError = EGL_BAD_ALLOC;
	goto cleanup_exit;

bad_match:
	psTls->lastError = EGL_BAD_MATCH;
	goto cleanup_exit;

bad_parameter:
	psTls->lastError = EGL_BAD_PARAMETER;
	goto cleanup_exit;

bad_attrib:
	psTls->lastError = EGL_BAD_ATTRIBUTE;

cleanup_exit:
	if (psSurface)
	{
		if (psSurface->u.pbuffer.psMemInfo)
		{
			/* drawable meminfo was allocated, make sure it is freed again */
			GWS_DeletePBufferDrawable(psSurface, &psTls->psGlobalData->sSysContext);
		}

		CFGC_Unlink(psSurface->psCfg); /* CFGC_Unlink does the null check */
		EGLFree(psSurface);
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferSurface);

	return EGL_NO_SURFACE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglDestroySurface
 *  PURPOSE    : Destroy a window, pixmap or pbuffer surface.
 *  PARAMETERS : In:  psDpy
 *               In:  psSurf
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE
 *               Failure. The error code can be retreived with eglGetError.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglDestroySurface(EGLDisplay eglDpy, EGLSurface eglSurface)
{
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	EGLint index;
	KEGL_SURFACE *psSurface = (KEGL_SURFACE *)eglSurface;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglDestroySurface"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglDestroySurface);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroySurface);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroySurface);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroySurface);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroySurface);

		return EGL_FALSE;
	}

	if (psSurface==EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroySurface);

		return EGL_FALSE;
	}

	if(!IsEGLSurface(psDpy, psSurface))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroySurface);

		return EGL_FALSE;
	}

	EGLThreadLock(psTls);

	if (psSurface->refCount>0)
	{
		psSurface->isDeleting = EGL_TRUE;
	}
	else
	{
		_SurfaceDelete(&psTls->psGlobalData->sSysContext, psSurface);
	}

	EGLThreadUnlock(psTls);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroySurface);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglQuerySurface
 *  PURPOSE    : Query an attribute of a surface.
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  psSurface - Surface.
 *               In:  attribute - Attribute to query.
 *               In:  value - Receives the value of the queried attribute.
 *  RETURNS    : EGL_TRUE - Success
 *               EGL_FALSE - Failure
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglQuerySurface(EGLDisplay eglDpy,
										 EGLSurface eglSurface,
										 EGLint attribute,
										 EGLint *value)
{
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	EGLDrawableParams sParams;
	EGLint index;
	KEGL_SURFACE *psSurface = (KEGL_SURFACE *)eglSurface;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglQuerySurface"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglQuerySurface);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

		return EGL_FALSE;
	}

	if(!IsEGLSurface(psDpy, psSurface))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

		return EGL_FALSE;
	}

	if (psSurface==EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

		return EGL_FALSE;
	}

	if (value==0)
	{
		psTls->lastError = EGL_BAD_PARAMETER;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

		return EGL_FALSE;
	}

	if (!KEGLGetDrawableParameters(psSurface, &sParams, IMG_TRUE))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

		return EGL_FALSE;
	}

	switch (attribute)
	{
		case EGL_WIDTH:
		{
			*value = sParams.ui32Width;

			break;
		}
		case EGL_HEIGHT:
		{
			*value = sParams.ui32Height;

			break;
		}
		case EGL_CONFIG_ID:
		{
			*value = CFGC_GetAttrib(psSurface->psCfg, attribute);

			break;
		}
		case EGL_LARGEST_PBUFFER:
		{
			if (psSurface->type==EGL_SURFACE_PBUFFER)
			{
				*value = psSurface->u.pbuffer.bLargest;
			}

			/* note for other window types *value is not updated! */

			break;
		}
		case EGL_TEXTURE_FORMAT:
		{
			if (psSurface->type==EGL_SURFACE_PBUFFER)
			{
				switch(psSurface->u.pbuffer.eTextureFormat)
				{
					case PVRSRV_PIXEL_FORMAT_UNKNOWN:
					default:
					{
						*value = EGL_NO_TEXTURE;

						break;
					}
					case PVRSRV_PIXEL_FORMAT_RGB565:
					{
						*value = EGL_TEXTURE_RGB;

						break;
					}
					case PVRSRV_PIXEL_FORMAT_ARGB8888:
					{
						*value = EGL_TEXTURE_RGBA;

						break;
					}
				}
			}

			break;
		}
		case EGL_TEXTURE_TARGET:
		{
			if(psSurface->type==EGL_SURFACE_PBUFFER)
			{
				if(psSurface->u.pbuffer.bTexture)
				{
					*value = EGL_TEXTURE_2D;
				}
				else
				{
					*value = EGL_NO_TEXTURE;
				}
			}

			break;
		}
		case EGL_MIPMAP_TEXTURE:
		{
			if(psSurface->type==EGL_SURFACE_PBUFFER)
			{
				if(psSurface->u.pbuffer.bMipMap)
				{
					*value = EGL_TRUE;
				}
				else
				{
					*value = EGL_FALSE;
				}
			}

			break;
		}
		case EGL_MIPMAP_LEVEL:
		{
			if(psSurface->type==EGL_SURFACE_PBUFFER)
			{
				*value = psSurface->u.pbuffer.ui32Level;
			}

			break;
		}
		case EGL_VG_ALPHA_FORMAT:
		{
			if (psSurface->sRenderSurface.eAlphaFormat == PVRSRV_ALPHA_FORMAT_PRE)
			{
				*value = EGL_ALPHA_FORMAT_PRE;
			}
			else
			{
				/* Default value for EGL_VG_ALPHA_FORMAT */
				*value = EGL_ALPHA_FORMAT_NONPRE;
			}

			break;
		}
		case EGL_VG_COLORSPACE:
		{
			if (psSurface->sRenderSurface.eColourSpace == PVRSRV_COLOURSPACE_FORMAT_LINEAR)
			{
				*value = EGL_COLORSPACE_LINEAR;
			}
			else
			{
				/* Default value for EGL_VG_COLORSPACE */
				*value = EGL_COLORSPACE_sRGB;
			}

			break;
		}
		case EGL_HORIZONTAL_RESOLUTION:
		{
			*value = EGL_UNKNOWN;
			break;
		}
		case EGL_VERTICAL_RESOLUTION:
		{
			*value = EGL_UNKNOWN;
			break;
		}
		case EGL_PIXEL_ASPECT_RATIO:
		{
			*value = EGL_UNKNOWN;
			break;
		}
		case EGL_RENDER_BUFFER:
		{
			switch (psSurface->type)
			{
				case EGL_SURFACE_PBUFFER:
				{
					*value = EGL_BACK_BUFFER;
					break;
				}
				case EGL_SURFACE_PIXMAP:
				{
					*value = EGL_SINGLE_BUFFER;
					break;
				}
				case EGL_SURFACE_WINDOW:
				{
					*value = EGL_BACK_BUFFER;
					break;
				}

			}
			break;
		}
		case EGL_SWAP_BEHAVIOR:
		{
			*value = psSurface->iSwapBehaviour;

			break;
		}
		case EGL_MULTISAMPLE_RESOLVE:
		{
			*value = psSurface->iMultiSampleResolve;

			break;
		}

		default:
		{
			psTls->lastError = EGL_BAD_ATTRIBUTE;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

			return EGL_FALSE;
		}
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQuerySurface);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglCreateContext
 *  PURPOSE    : Create a rendering context.
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  eglCfg - Configuration.
 *               In:  pShareList - Shared context or IMG_NULL.
 *               In:  pAttribList - Attributes or IMG_NULL.
 *  RETURNS    : Context or EGL_NO_CONTEXT.
 *
 ***********************************************************************/
IMG_EXPORT EGLContext IMGeglCreateContext(EGLDisplay eglDpy,
										  EGLConfig eglCfg,
										  EGLContext pShareList,
										  const EGLint *pAttribList)
{
	KEGL_DISPLAY			*psDpy;
	KEGL_CONTEXT			*psCtx, *psShareList = (KEGL_CONTEXT *)pShareList;
	IMG_BOOL				imgResult = IMG_TRUE;
	EGLContextHandle		share_ctx;
	TLS						psTls;
	EGLint					index;

#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
	IMG_UINT32				ui32ContextVersion = 1;
#endif

	IMGEGL_CONTEXT_TYPE		eContextType = IMGEGL_CONTEXT_OPENGLES1;
	KEGL_CONFIG_INDEX		configIndex = (KEGL_CONFIG_INDEX)eglCfg;

#if defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)
	SGX_CONTEXT_PRIORITY	eContextPriority = SGX_CONTEXT_PRIORITY_HIGH;
#endif

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglCreateContext"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_NO_CONTEXT;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglCreateContext);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

		return EGL_NO_CONTEXT;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

		return EGL_NO_CONTEXT;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

		return EGL_NO_CONTEXT;
	}

	if (pAttribList!=IMG_NULL)
	{
		while (*pAttribList!=EGL_NONE)
		{
			EGLint attrib = *pAttribList++;
			EGLint value;

			value = *pAttribList++;

			switch (attrib)
			{
				case EGL_CONTEXT_CLIENT_VERSION:
				{
#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
					/* Can only set client version on OpenGLES, can only be 1 or 2 */
					if((value != 1 && value != 2) || (psTls->ui32API != IMGEGL_API_OPENGLES))
						goto bad_attrib;

					ui32ContextVersion = value;
#endif
					break;
				}
#if defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)
				case EGL_CONTEXT_PRIORITY_LEVEL_IMG:
				{
					switch(value)
					{
						case EGL_CONTEXT_PRIORITY_HIGH_IMG:
							eContextPriority = SGX_CONTEXT_PRIORITY_HIGH;
							break;
						case EGL_CONTEXT_PRIORITY_MEDIUM_IMG:
							eContextPriority = SGX_CONTEXT_PRIORITY_MEDIUM;
							break;
						case EGL_CONTEXT_PRIORITY_LOW_IMG:
							eContextPriority = SGX_CONTEXT_PRIORITY_LOW;
							break;
						default:
							goto bad_attrib;
					}

					break;
				}
#endif
				default:
#if defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING) || defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
bad_attrib:
#endif
					psTls->lastError = EGL_BAD_ATTRIBUTE;

					IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

					return EGL_NO_CONTEXT;
			}
		}
	}

	if(!IsEGLContext(psDpy, psShareList))
	{
		psTls->lastError = EGL_BAD_CONTEXT;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

		return EGL_NO_CONTEXT;
	}

	if (psShareList != IMG_NULL && psShareList->psDpy != psDpy)
	{
		psTls->lastError = EGL_BAD_MATCH;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

		return EGL_NO_CONTEXT;
	}

	psCtx = EGLCalloc(sizeof(*psCtx));

	if (psCtx==0)
	{
		psTls->lastError = EGL_BAD_ALLOC;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

		return EGL_NO_CONTEXT;
	}

	/* Sanity check: Should be zeroed by Calloc */
	PVR_ASSERT(psCtx->boundThread == 0);

	psCtx->isFirstMakeCurrent = EGL_TRUE;
	psCtx->isCurrent = EGL_FALSE;
	psCtx->isDeleting = EGL_FALSE;
	psCtx->psDpy = psDpy;
	psCtx->eglDpy = eglDpy;

	psTls->lastError = CFG_GenerateVariant(psDpy, configIndex, &psCtx->psCfg);

	if (psTls->lastError!=EGL_SUCCESS)
	{
		goto cleanup_exit;
	}

	_InitialiseContextMode(&psCtx->contextMode, psCtx->psCfg);

#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)

	if (psTls->ui32API==IMGEGL_API_OPENGLES)
	{
		switch(ui32ContextVersion)
		{

#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
			case 1:
			{
				if((psShareList!=IMG_NULL) && (psShareList->eContextType!=IMGEGL_CONTEXT_OPENGLES1))
				{
					psTls->lastError = EGL_BAD_MATCH;

					IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

					return EGL_NO_CONTEXT;
				}

				/* Check the config supports OpenGL ES 1.x */
				if (!(CFGC_GetAttrib(psCtx->psCfg, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES_BIT))
				{
					psTls->lastError = EGL_BAD_CONFIG;
					goto cleanup_exit;
				}

				if(!psTls->psGlobalData->bHaveOGLES1Functions)
				{
					if (!LoadOGLES1AndGetFunctions(psTls->psGlobalData))
					{
						psTls->lastError = EGL_NOT_INITIALIZED;

						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

						return IMG_NULL;
					}
				}

				eContextType = IMGEGL_CONTEXT_OPENGLES1;

				break;
			}
#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
			case 2:
			{
				if((psShareList!=IMG_NULL) && (psShareList->eContextType!=IMGEGL_CONTEXT_OPENGLES2))
				{
					psTls->lastError = EGL_BAD_MATCH;

					IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

					return EGL_NO_CONTEXT;
				}

				/* Check the config supports OpenGL ES 2.x */
				if (!(CFGC_GetAttrib(psCtx->psCfg, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES2_BIT))
				{
					psTls->lastError = EGL_BAD_CONFIG;
					goto cleanup_exit;
				}

				if(!psTls->psGlobalData->bHaveOGLES2Functions)
				{
					if (!LoadOGLES2AndGetFunctions(psTls->psGlobalData))
					{
						psTls->lastError = EGL_NOT_INITIALIZED;

						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

						return IMG_NULL;
					}
				}

				eContextType = IMGEGL_CONTEXT_OPENGLES2;

				break;
			}
#endif /* defined(SUPPORT_OPENGLES2) ||defined(API_MODULES_RUNTIME_CHECKED) */

			default:
				/* Invalid combination of context version and implementation present */
				psTls->lastError = EGL_NOT_INITIALIZED;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

				return IMG_NULL;
		}
	}
#endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2)||defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	if (psTls->ui32API==IMGEGL_API_OPENGL)
	{
		if((psShareList!=IMG_NULL) && (psShareList->eContextType!=IMGEGL_CONTEXT_OPENGL))
		{
			psTls->lastError = EGL_BAD_MATCH;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

			return EGL_NO_CONTEXT;
		}

		/* Check the config supports OpenGL */
		if (!(CFGC_GetAttrib(psCtx->psCfg, EGL_RENDERABLE_TYPE) & EGL_OPENGL_BIT))
		{
			psTls->lastError = EGL_BAD_CONFIG;
			goto cleanup_exit;
		}

		if(!psTls->psGlobalData->bHaveOGLFunctions)
		{
			if (!LoadOGLAndGetFunctions(psTls->psGlobalData))
			{
				psTls->lastError = EGL_NOT_INITIALIZED;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

				return IMG_NULL;
			}
		}
		eContextType = IMGEGL_CONTEXT_OPENGL;
	}
#endif /* defined(SUPPORT_OPENGL) ||defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
	if (psTls->ui32API==IMGEGL_API_OPENVG)
	{
		if((psShareList!=IMG_NULL) && (psShareList->eContextType!=IMGEGL_CONTEXT_OPENVG))
		{
			psTls->lastError = EGL_BAD_MATCH;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

			return EGL_NO_CONTEXT;
		}

		/* Check the config supports OpenVG */
		if (!(CFGC_GetAttrib(psCtx->psCfg, EGL_RENDERABLE_TYPE) & EGL_OPENVG_BIT))
		{
			psTls->lastError = EGL_BAD_CONFIG;
			goto cleanup_exit;
		}

		if(!psTls->psGlobalData->bHaveOVGFunctions)
		{
			if (!LoadOVGAndGetFunctions(psTls->psGlobalData))
			{
				psTls->lastError = EGL_NOT_INITIALIZED;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

				return IMG_NULL;
			}
		}
		eContextType = IMGEGL_CONTEXT_OPENVG;
	}
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) ||defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENCL) || defined(API_MODULES_RUNTIME_CHECKED)

#if defined(API_MODULES_RUNTIME_CHECKED)
	if(psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENCL])
#endif /* defined(API_MODULES_RUNTIME_CHECKED) */
	{
		if(!psTls->psGlobalData->bHaveOCLFunctions)
		{
			if (!LoadOCLAndGetFunctions(psTls->psGlobalData))
			{
				psTls->lastError = EGL_NOT_INITIALIZED;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

				return IMG_NULL;
			}
		}
	}
#endif /* defined(SUPPORT_OPENCL) ||defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)
	psCtx->contextMode.eContextPriority = eContextPriority;

	if(!KEGL_SGXSetContextPriority(&psTls->psGlobalData->sSysContext, &psCtx->contextMode.eContextPriority))
	{
		psTls->lastError = EGL_BAD_ALLOC;

		goto cleanup_exit;
	}
#endif /* defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING) */

#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
	if (psTls->ui32API == IMGEGL_API_OPENGLES)
	{
		if (psShareList!=IMG_NULL)
		{
			share_ctx = psShareList->hClientContext;
		}
		else
		{
			share_ctx = IMG_NULL;
		}

#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
		if(ui32ContextVersion == 1)
		{

#   if defined(API_MODULES_RUNTIME_CHECKED)
			if(!psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1])
			{
				imgResult = IMG_FALSE;
			}
			else
#   endif
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
				PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESCreateGC)

				imgResult = psTls->psGlobalData->spfnOGLES1.pfnGLESCreateGC(&psTls->psGlobalData->sSysContext,
															  &psCtx->hClientContext,
															  &psCtx->contextMode,
															  share_ctx);
			}
		}
#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
		if(ui32ContextVersion == 2)
		{
#   if defined(API_MODULES_RUNTIME_CHECKED)
			if(!psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2])
			{
				imgResult = IMG_FALSE;
			}
			else
#   endif
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOGLES2Functions)
				PVR_ASSERT(psTls->psGlobalData->spfnOGLES2.pfnGLESCreateGC)

				imgResult = psTls->psGlobalData->spfnOGLES2.pfnGLESCreateGC(&psTls->psGlobalData->sSysContext,
															  &psCtx->hClientContext,
															  &psCtx->contextMode,
															  share_ctx);
			}
		}
#endif /* defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED) */

	}
	else
#endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) ||defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	if (psTls->ui32API == IMGEGL_API_OPENGL)
	{
		if (psShareList!=IMG_NULL)
		{
			share_ctx = psShareList->hClientContext;
		}
		else
		{
			share_ctx = IMG_NULL;
		}

#   if defined(API_MODULES_RUNTIME_CHECKED)
		if(!psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL])
		{
			imgResult = IMG_FALSE;
		}
		else
#   endif
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLCreateGC)

			imgResult = psTls->psGlobalData->spfnOGL.pfnGLCreateGC(&psTls->psGlobalData->sSysContext,
														&psCtx->hClientContext,
														&psCtx->contextMode,
														share_ctx);
		}
	}
	else
#endif /* defined(SUPPORT_OPENGL) ||defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)
	if (psTls->ui32API == IMGEGL_API_OPENVG)
	{
		if (psShareList!=IMG_NULL)
		{
			share_ctx = psShareList->hClientContext;
		}
		else
		{
			share_ctx = IMG_NULL;
		}

#   if defined(API_MODULES_RUNTIME_CHECKED)
		if(!psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG])
		{
			imgResult = IMG_FALSE;
		}
		else
#   endif
		{
			imgResult = psTls->psGlobalData->spfnOVG.pfnOVGCreateGC(&psTls->psGlobalData->sSysContext,
													  &psCtx->hClientContext,
													  &psCtx->contextMode,
													  share_ctx);
		}
	}
	else
#endif /* defined(SUPPORT_OPENGL) ||defined(API_MODULES_RUNTIME_CHECKED) */
	{
		imgResult = IMG_FALSE;

		PVR_DPF((PVR_DBG_WARNING,"IMGeglCreateContext: Invalid client API"));
	}

	if (!imgResult)
	{
		psTls->lastError = EGL_BAD_ALLOC;

		goto cleanup_exit;
	}

	psCtx->eContextType  = eContextType;

	EGLThreadLock(psTls);

	/* Chain the new context onto the displays context list */
	psCtx->psNextContext = psDpy->psHeadContext;
	psDpy->psHeadContext = psCtx;

	EGLThreadUnlock(psTls);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

	return psCtx;

cleanup_exit:

	CFGC_Unlink(psCtx->psCfg); /* CFGC_Unlink does the null check */

	EGLFree(psCtx);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreateContext);

	return EGL_NO_CONTEXT;
}


/***********************************************************************
 *
 *  FUNCTION   : eglDestroyContext
 *  PURPOSE    : Delete a rendering context.
 *  PARAMETERS : In:  eglDpy - Display that the context was created on.
 *               In:  eglContext - The context to destroy.
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 ***********************************************************************/
IMG_EXPORT EGLBoolean IMGeglDestroyContext(EGLDisplay eglDpy, EGLContext eglContext)
{
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	EGLint index;
	KEGL_CONTEXT *psCtx = (KEGL_CONTEXT *)eglContext;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglDestroyContext"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglDestroyContext);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroyContext);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroyContext);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroyContext);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroyContext);

		return EGL_FALSE;
	}

	if(!IsEGLContext(psDpy, psCtx))
	{
		psTls->lastError = EGL_BAD_CONTEXT;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroyContext);

		return EGL_FALSE;
	}

	if (psCtx==EGL_NO_CONTEXT)
	{
		psTls->lastError = EGL_BAD_CONTEXT;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroyContext);

		return EGL_FALSE;
	}

	if (psCtx->isCurrent)
	{
		psCtx->isDeleting = EGL_TRUE;
	}
	else
	{
		psTls->lastError =_ContextDelete(psCtx, IMG_FALSE);

		if (psTls->lastError != EGL_SUCCESS)
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroyContext);

			return EGL_FALSE;
		}
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglDestroyContext);

	return EGL_TRUE;
}


static WSEGLDrawableHandle GetNonPBufferWSEGLDrawable(KEGL_SURFACE *psSurface)
{
	switch(psSurface->type)
	{
		case EGL_SURFACE_WINDOW:
		{
			return psSurface->u.window.hDrawable;
		}

		case EGL_SURFACE_PIXMAP:
		{
			return psSurface->u.pixmap.hDrawable;
		}

		default:
		{
			return WSEGL_NULL;
		}
	}
}

static EGLint ConnectSurface(KEGL_DISPLAY *psDpy, KEGL_SURFACE *psSurface)
{
	WSEGLDrawableHandle hDrawable;
	WSEGLError eError;

	hDrawable = GetNonPBufferWSEGLDrawable(psSurface);

	if(hDrawable != WSEGL_NULL)
	{
		/* This function is called without the EGL lock held, so we don't
		   need to release the lock here for an unlocked WSEGL module. */
		eError = psDpy->pWSEGL_FT->pfnWSEGL_ConnectDrawable(hDrawable);

		if (eError != WSEGL_SUCCESS)
		{
			return EGL_BAD_ALLOC; /* FIXME!! */
		}
	}

	return EGL_SUCCESS;
}

static EGLint DisconnectSurface(KEGL_DISPLAY *psDpy, KEGL_SURFACE *psSurface)
{
	WSEGLDrawableHandle hDrawable;
	WSEGLError eError;
	TLS psTls;

	psTls = TLS_Open(_TlsInit);

	hDrawable = GetNonPBufferWSEGLDrawable(psSurface);

	if(hDrawable != WSEGL_NULL)
	{
		/* This function is called with the EGL lock held, so we need to
		   release the lock here for an unlocked WSEGL module. */
		EGLReleaseThreadLockWSEGL(psDpy, psTls);
		eError = psDpy->pWSEGL_FT->pfnWSEGL_DisconnectDrawable(hDrawable);
		EGLReacquireThreadLockWSEGL(psDpy, psTls);

		if (eError != WSEGL_SUCCESS)
		{
			return EGL_BAD_ALLOC; /* FIXME!! */
		}
	}

	return EGL_SUCCESS;
}

/***********************************************************************
 *
 *  FUNCTION   : eglMakeCurrent
 *  PURPOSE    : Bind draw and read surfaces to a context making them current.
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  draw - Draw surface or EGL_NO_SURFACE.
 *               In:  read - Read surface or EGL_NO_SURFACE.
 *               In:  psCtx - Context or EGL_NO_CONTEXT.
 *  RETURNS    : EGL_TRUE - Success
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglMakeCurrent(EGLDisplay eglDpy,
										EGLSurface draw,
										EGLSurface read,
										EGLContext eglContext)
{
	TLS psTls;
	EGLDrawableParams sParams;
	KEGL_DISPLAY *psDpy;
	EGLint index;
	KEGL_CONTEXT *psCtx = (KEGL_CONTEXT *)eglContext;
	KEGL_SURFACE *psDrawSurface = (KEGL_SURFACE *)draw;
	KEGL_SURFACE *psReadSurface = (KEGL_SURFACE *)read;
	IMG_UINT32 ui32NewContextAPI = IMGEGL_API_NONE;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglMakeCurrent"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglMakeCurrent);

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}
#endif

	psTls->lastError = EGL_SUCCESS;

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}

	if(!IsEGLSurface(psDpy, psDrawSurface))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}

	if(!IsEGLSurface(psDpy, psReadSurface))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}

	if(!IsEGLContext(psDpy, psCtx))
	{
		psTls->lastError = EGL_BAD_CONTEXT;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}
#endif

#if defined(API_MODULES_RUNTIME_CHECKED)

	if(psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG])
	{
		if(
			(psCtx != EGL_NO_CONTEXT) &&
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENVG)
		)
		{
			if (psDrawSurface != psReadSurface)
			{
				/* OPENVG - IS THIS ERROR CORRECT? */
				psTls->lastError = EGL_BAD_SURFACE;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}
		}
		else if(
			(psTls->ui32API == IMGEGL_API_NONE) &&
			!psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1] &&
			!psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2]
		)
		{
			/* OPENVG - IS THIS ERROR CORRECT? */
			psTls->lastError = EGL_BAD_PARAMETER;

			PVR_DPF((PVR_DBG_WARNING,"IMGeglMakeCurrent: Invalid client API"));

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

			return EGL_FALSE;
		}
	}

#else /* API_MODULES_RUNTIME_CHECKED */

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)
	if ( psCtx != EGL_NO_CONTEXT &&
		 psCtx->eContextType == IMGEGL_CONTEXT_OPENVG )
	{
		if (psDrawSurface != psReadSurface)
		{
			/* OPENVG - IS THIS ERROR CORRECT? */
			psTls->lastError = EGL_BAD_SURFACE;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

			return EGL_FALSE;
		}
	}
#if !defined(SUPPORT_OPENGLES1) && !defined(SUPPORT_OPENGLES2)
	else if (psTls->ui32API == IMGEGL_API_NONE)
	{
		/* OPENVG - IS THIS ERROR CORRECT? */
		psTls->lastError = EGL_BAD_PARAMETER;

		PVR_DPF((PVR_DBG_WARNING,"IMGeglMakeCurrent: Invalid client API"));

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}
#endif /* !defined(SUPPORT_OPENGLES1) && !defined(SUPPORT_OPENGLES2) */
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) */

#endif /* API_MODULES_RUNTIME_CHECKED */


	/*
		If psCtx is bound to another thread or draw or read are bound to
		contexts in another thread then BAD_ACCESS.
	*/
	if (_ContextBoundToOtherThread(psCtx) ||
		_SurfaceBoundToOtherThread(psReadSurface) ||
		_SurfaceBoundToOtherThread(psDrawSurface))
	{
		psTls->lastError = EGL_BAD_ACCESS;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}

	/*
		If ctx is EGL_NO_CONTEXT and draw or read are not EGL_NO_SURFACE, or
		if draw or read are set to EGL_NO_SURFACE and ctx is not
		EGL_NO_CONTEXT, then an EGL_BAD_MATCH error will be generated.
	*/
	if (psCtx==EGL_NO_CONTEXT && (psReadSurface!=EGL_NO_SURFACE || psDrawSurface!=EGL_NO_SURFACE))
	{
		psTls->lastError = EGL_BAD_MATCH;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}

	if (psCtx!=EGL_NO_CONTEXT && (psReadSurface==EGL_NO_SURFACE || psDrawSurface==EGL_NO_SURFACE))
	{
		psTls->lastError = EGL_BAD_MATCH;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}

	if (psCtx!=EGL_NO_CONTEXT)
	{
		if (psReadSurface!=EGL_NO_SURFACE)
		{
			if (!_CompatibleContextAndSurface(psCtx, psReadSurface))
			{
				psTls->lastError = EGL_BAD_MATCH;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}
		}

		if (psDrawSurface!=EGL_NO_SURFACE)
		{
			if (!_CompatibleContextAndSurface(psCtx, psDrawSurface))
			{
				psTls->lastError = EGL_BAD_MATCH;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}
		}
	}

	/* if native window/pixmap behind draw has become invalid */
	if (psDrawSurface!=EGL_NO_SURFACE &&
		psDrawSurface->type!=EGL_SURFACE_PBUFFER &&
		!KEGLGetDrawableParameters(psDrawSurface, &sParams, IMG_TRUE))
	{
		psTls->lastError = EGL_BAD_NATIVE_WINDOW;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}

	/* if native window/pixmap behind read has become invalid */
	if (psReadSurface!=EGL_NO_SURFACE &&
		psReadSurface->type!=EGL_SURFACE_PBUFFER &&
			!KEGLGetDrawableParameters(psReadSurface, &sParams, IMG_TRUE))
	{
		psTls->lastError = EGL_BAD_NATIVE_WINDOW;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_FALSE;
	}


	/*
	** From spec (3.7.3 Binding Contexts and Drawables):
	**
	** This is the only case in which eglMakeCurrent respects the current rendering API.
	**
	** In all other cases, the client API affected is determined by ctx
	*/
	if(psCtx==EGL_NO_CONTEXT)
	{
		ui32NewContextAPI = psTls->ui32API;
	}
	else
	{
		IMG_UINT32 ui32API;

#if defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENGL) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL]
		)
		{
			ui32NewContextAPI = IMGEGL_API_OPENGL;
		}
		else if(
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENGLES1) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1]
		)
		{
			ui32NewContextAPI = IMGEGL_API_OPENGLES;
		}
		else if(
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENGLES2) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2]
		)
		{
			ui32NewContextAPI = IMGEGL_API_OPENGLES;
		}
		else if(
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENVG) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG]
		)
		{
			ui32NewContextAPI = IMGEGL_API_OPENVG;
		}
		else 
		{
			PVR_DPF((PVR_DBG_WARNING,"IMGeglMakeCurrent: Unsupported context API"));

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

			return EGL_FALSE;
		}

#else /* defined(API_MODULES_RUNTIME_CHECKED) */

		switch(psCtx->eContextType)
		{
#if defined (SUPPORT_OPENGL)
			case IMGEGL_CONTEXT_OPENGL:
			{
				ui32NewContextAPI = IMGEGL_API_OPENGL;

				break;
			}
#endif /* defined (SUPPORT_OPENGL) */
#if defined(SUPPORT_OPENGLES1)
			case IMGEGL_CONTEXT_OPENGLES1:
			{
				ui32NewContextAPI = IMGEGL_API_OPENGLES;

				break;
			}
#endif /* defined(SUPPORT_OPENGLES1) */
#if defined(SUPPORT_OPENGLES2)
			case IMGEGL_CONTEXT_OPENGLES2:
			{
				ui32NewContextAPI = IMGEGL_API_OPENGLES;

				break;
			}
#endif /* defined(SUPPORT_OPENGLES2) */
#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)
			case IMGEGL_CONTEXT_OPENVG:
			{
				ui32NewContextAPI = IMGEGL_API_OPENVG;

				break;
			}
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) */
			default:
			{
				PVR_DPF((PVR_DBG_WARNING,"IMGeglMakeCurrent: Unsupported context API"));

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}
		}

#endif /* defined(API_MODULES_RUNTIME_CHECKED) */

		for(ui32API=0; ui32API<IMGEGL_NUMBER_OF_APIS; ui32API++)
		{
			/* Ignore the API that we're making current */
			if(ui32API==ui32NewContextAPI)
			{
				continue;
			}

			/*
			** From spec (3.7 Rendering Contexts):
			**
			** At most one context for each supported client API may be current to a particular thread
			** at a given time, and at most one context may be bound to a particular surface at a given time. (*8)
			**
			** (*8) Note that this implies that implementations must allow (for example) both an OpenGL ES and
			** an OpenVG context to be current to the same thread, so long as they are drawing to different surfaces.
			*/
			if((psTls->apsCurrentDrawSurface[ui32API]==psDrawSurface) ||
			   (psTls->apsCurrentDrawSurface[ui32API]==psReadSurface) ||
			   (psTls->apsCurrentReadSurface[ui32API]==psDrawSurface) ||
			   (psTls->apsCurrentReadSurface[ui32API]==psReadSurface))
			{
				psTls->lastError = EGL_BAD_ACCESS;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}
		}
	}


	/* Optimise case where nothing has changed */
	if((psTls->apsCurrentContext[ui32NewContextAPI] == psCtx) &&
	   (psTls->apsCurrentReadSurface[ui32NewContextAPI] == read) &&
	   (psTls->apsCurrentDrawSurface[ui32NewContextAPI] == draw))
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

		return EGL_TRUE;
	}

	/* We are flushing commands on current context/surface, so we won't need to check for BAD_CURRENT_SURFACE
	 * in the future
	 */
	if (psTls->apsCurrentContext[ui32NewContextAPI] != EGL_NO_CONTEXT)
	{
		IMG_EGLERROR eError;
		KEGL_CONTEXT *psCurrentContext;

		psCurrentContext = psTls->apsCurrentContext[ui32NewContextAPI];
		psTls->apsCurrentContext[ui32NewContextAPI] = EGL_NO_CONTEXT;

		psCurrentContext->isCurrent = EGL_FALSE;

#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psCurrentContext->eContextType == IMGEGL_CONTEXT_OPENGLES1) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC(psCurrentContext->hClientContext,
																		   &psTls->apsCurrentDrawSurface[ui32NewContextAPI]->sRenderSurface,
																			IMG_TRUE,
																			IMG_FALSE,
																			IMG_TRUE);

			if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}

			psTls->psGlobalData->spfnOGLES1.pfnGLESMakeUnCurrentGC();
		}
		else
#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psCurrentContext->eContextType == IMGEGL_CONTEXT_OPENGLES2) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES2Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC(psCurrentContext->hClientContext,
																		    IMG_NULL,
																			IMG_TRUE,
																			IMG_FALSE,
																			IMG_TRUE);

			if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}
			psTls->psGlobalData->spfnOGLES2.pfnGLESMakeUnCurrentGC();
		}
		else
#endif /* defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psCurrentContext->eContextType == IMGEGL_CONTEXT_OPENGL) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC(psCurrentContext->hClientContext,
															IMG_FALSE,
															IMG_TRUE);

			if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}

			psTls->psGlobalData->spfnOGL.pfnGLMakeUnCurrentGC();
		}
		else
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psCurrentContext->eContextType == IMGEGL_CONTEXT_OPENVG) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOVGFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOVG.pfnOVGFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOVG.pfnOVGFlushBuffersGC(psCurrentContext->hClientContext,
														IMG_FALSE,
														IMG_TRUE);

			if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}

			psTls->psGlobalData->spfnOVG.pfnOVGMakeUnCurrentGC();
		}
		else
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED) */
		{
			PVR_DPF((PVR_DBG_WARNING,"IMGeglMakeCurrent: Invalid client API"));
		}


		if (psCurrentContext->isDeleting && psCurrentContext != psCtx)
		{
			/* The previous current context has been marked for
			 * deletion. Deletion of a context ?might? fail in which
			 * case we report the failure here. The sequence is odd,
			 * the app called eglDestroyContext which reported success
			 * followed eventually by eglMakeCurrent which actually
			 * detects a problem with destroying the context and
			 * reports an error. This behaviour is preferable to
			 * simply hiding the failure from the application. */

			/* If the context is marked for deletion and the same
			 * handle has been passed in as the new context then
			 * keeping it around is the safest thing todo. We could
			 * delete the context, and return EGL_BAD_CONTEXT, but
			 * this would cause inconsistent behaviour when compared
			 * to cases where the 'nothing has changed' optimisation
			 * gets used */
			psTls->lastError = _ContextDelete(psCurrentContext, IMG_FALSE);

			if (psTls->lastError!=EGL_SUCCESS)
			{
				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}
		}
	}

	EGLThreadLock(psTls);

	if (psTls->apsCurrentReadSurface[ui32NewContextAPI]!=EGL_NO_SURFACE)
	{
		psTls->lastError = DisconnectSurface(psDpy, psTls->apsCurrentReadSurface[ui32NewContextAPI]);

		if (psTls->lastError != EGL_SUCCESS)
		{
			EGLThreadUnlock(psTls);

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

			return EGL_FALSE;
		}

		_SurfaceUnbind(&psTls->psGlobalData->sSysContext, psTls->apsCurrentReadSurface[ui32NewContextAPI]);

		psTls->apsCurrentReadSurface[ui32NewContextAPI] = EGL_NO_SURFACE;
	}

	if (psTls->apsCurrentDrawSurface[ui32NewContextAPI]!=EGL_NO_SURFACE)
	{
		psTls->lastError = DisconnectSurface(psDpy, psTls->apsCurrentDrawSurface[ui32NewContextAPI]);

		if (psTls->lastError != EGL_SUCCESS)
		{
			EGLThreadUnlock(psTls);

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

			return EGL_FALSE;
		}

		_SurfaceUnbind(&psTls->psGlobalData->sSysContext, psTls->apsCurrentDrawSurface[ui32NewContextAPI]);

		psTls->apsCurrentDrawSurface[ui32NewContextAPI] = EGL_NO_SURFACE;
	}

	EGLThreadUnlock(psTls);

	if (psCtx!=EGL_NO_CONTEXT)
	{
		IMG_EGLERROR imgResult;
		IMG_UINT32 ui32TLSId;
		EGLRenderSurface *psDrawRenderSurface, *psReadRenderSurface;

		if (draw!=EGL_NO_SURFACE)
		{
			psDrawRenderSurface = &psDrawSurface->sRenderSurface;
		}
		else
		{
			psDrawRenderSurface = IMG_NULL;
		}

		if (read!=EGL_NO_SURFACE)
		{
			psReadRenderSurface = &psReadSurface->sRenderSurface;
		}
		else
		{
			psReadRenderSurface = IMG_NULL;
		}

		if (psCtx->isFirstMakeCurrent)
		{
			psCtx->isFirstMakeCurrent = EGL_FALSE;
		}

		if (psReadSurface != EGL_NO_SURFACE)
		{
			psTls->lastError = ConnectSurface(psDpy, psReadSurface);

			if (psTls->lastError != EGL_SUCCESS)
			{
				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}
		}

		if (psDrawSurface != EGL_NO_SURFACE)
		{
			psTls->lastError = ConnectSurface(psDpy, psDrawSurface);

			if (psTls->lastError != EGL_SUCCESS)
			{
				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}
		}

#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENGLES1) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESMakeCurrentGC)

			imgResult = psTls->psGlobalData->spfnOGLES1.pfnGLESMakeCurrentGC(psDrawRenderSurface, psReadRenderSurface, psCtx->hClientContext);
		}
		else
#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENGLES2) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES2Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES2.pfnGLESMakeCurrentGC)

			imgResult = psTls->psGlobalData->spfnOGLES2.pfnGLESMakeCurrentGC(psDrawRenderSurface, psReadRenderSurface, psCtx->hClientContext);
		}
		else
#endif /* defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENGL) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLMakeCurrentGC)

			imgResult = psTls->psGlobalData->spfnOGL.pfnGLMakeCurrentGC(psDrawRenderSurface, psReadRenderSurface, psCtx->hClientContext);
		}
		else
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psCtx->eContextType == IMGEGL_CONTEXT_OPENVG) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOVGFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOVG.pfnOVGMakeCurrentGC)

			imgResult = psTls->psGlobalData->spfnOVG.pfnOVGMakeCurrentGC(psDrawRenderSurface, psReadRenderSurface, psCtx->hClientContext);
		}
		else
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED) */
		{
			imgResult = IMG_EGL_GENERIC_ERROR;

			PVR_DPF((PVR_DBG_WARNING,"IMGeglMakeCurrent: Invalid client API"));
		}

		if (imgResult != IMG_EGL_NO_ERROR)
		{
			if (imgResult == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}

			if (imgResult == IMG_EGL_GENERIC_ERROR)
			{
				psTls->lastError = EGL_BAD_ALLOC;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

				return EGL_FALSE;
			}

			PVR_DPF((PVR_DBG_ERROR, "IMGeglMakeCurrent: unexpected error code"));

			psTls->lastError = EGL_BAD_ALLOC;/* arbitrary choice */

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

			return EGL_FALSE;
		}

		ui32TLSId = IMGEGL_GetTLSID();

		psTls->apsCurrentContext[ui32NewContextAPI] = psCtx;
		psTls->apsCurrentContext[ui32NewContextAPI]->isCurrent = EGL_TRUE;
		psTls->apsCurrentContext[ui32NewContextAPI]->boundThread = ui32TLSId;

		psTls->apsCurrentReadSurface[ui32NewContextAPI] = psReadSurface;

		if (psReadSurface!=EGL_NO_SURFACE)
		{
			psReadSurface->currentCount++;
			psReadSurface->refCount++;

			psReadSurface->boundThread = ui32TLSId;
		}

		psTls->apsCurrentDrawSurface[ui32NewContextAPI] = psDrawSurface;

		if (psDrawSurface!=EGL_NO_SURFACE)
		{
			psDrawSurface->currentCount++;
			psDrawSurface->refCount++;

			psDrawSurface->boundThread = ui32TLSId;
		}
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglMakeCurrent);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglGetCurrentContext
 *  PURPOSE    : Retreive the current context, if any.
 *  PARAMETERS : None.
 *  RETURNS    : Current context or EGL_NO_CONTEXT.
 *
 **********************************************************************/
IMG_EXPORT EGLContext IMGeglGetCurrentContext(void)
{
	TLS psTls;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglGetCurrentContext"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_NO_CONTEXT;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglGetCurrentContext);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetCurrentContext);

		return EGL_NO_CONTEXT;
	}
#endif

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetCurrentContext);

	return psTls->apsCurrentContext[psTls->ui32API];
}


/***********************************************************************
 *
 *  FUNCTION   : eglGetCurrentSurface
 *  PURPOSE    : Retreive the current draw or read surface if any.
 *  PARAMETERS : In:  readdraw - retreive the draw or read surface.
 *  RETURNS    : Surface or EGL_NO_SURFACE.
 *
 **********************************************************************/
IMG_EXPORT EGLSurface IMGeglGetCurrentSurface(EGLint readdraw)
{
	TLS psTls;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglGetCurrentSurface"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_NO_SURFACE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglGetCurrentSurface);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetCurrentSurface);

		return EGL_NO_SURFACE;
	}
#endif

	switch (readdraw)
	{
		case EGL_READ:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetCurrentSurface);

			return psTls->apsCurrentReadSurface[psTls->ui32API];
		}
		case EGL_DRAW:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetCurrentSurface);

			return psTls->apsCurrentDrawSurface[psTls->ui32API];
		}
		default:
		{
			break;
		}
	}

	psTls->lastError = EGL_BAD_PARAMETER;

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetCurrentSurface);

	return EGL_NO_SURFACE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglGetCurrentDisplay
 *  PURPOSE    : Retreive the current display, if any.
 *  PARAMETERS : None.
 *  RETURNS    : Display or EGL_NO_DISPLAY.
 *
 **********************************************************************/
IMG_EXPORT EGLDisplay IMGeglGetCurrentDisplay(void)
{
	TLS psTls;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglGetCurrentDisplay"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_NO_DISPLAY;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglGetCurrentDisplay);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetCurrentDisplay);

		return EGL_FALSE;
	}
#endif

	if (psTls->apsCurrentContext[psTls->ui32API]==EGL_NO_CONTEXT)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetCurrentDisplay);

		return EGL_NO_DISPLAY;
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglGetCurrentDisplay);

	return psTls->apsCurrentContext[psTls->ui32API]->eglDpy;
}

/***********************************************************************
 *
 *  FUNCTION   : eglQueryContext
 *  PURPOSE    : Query an attribute of a context.
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  psCtx - Context.
 *               In:  attribute - Attribute to query.
 *               Out: value - Receives the queried attribute value.
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglQueryContext(EGLDisplay eglDpy,
										 EGLContext eglContext,
										 EGLint attribute,
										 EGLint *value)
{
	KEGL_DISPLAY *psDpy;
	KEGL_CONTEXT *psContext = (KEGL_CONTEXT *)eglContext;
	TLS psTls;
	EGLint index;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglQueryContext"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglQueryContext);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryContext);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryContext);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryContext);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryContext);

		return EGL_FALSE;
	}

	if(!IsEGLContext(psDpy, psContext))
	{
		psTls->lastError = EGL_BAD_CONTEXT;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryContext);

		return EGL_FALSE;
	}

	if (psContext==EGL_NO_CONTEXT)
	{
		psTls->lastError = EGL_BAD_CONTEXT;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryContext);

		return EGL_FALSE;
	}

	if (value==0)
	{
		psTls->lastError = EGL_BAD_PARAMETER;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryContext);

		return EGL_FALSE;
	}

	switch (attribute)
	{
		case EGL_CONFIG_ID:
		{
			*value = CFGC_GetAttrib(psContext->psCfg, attribute);
			break;
		}

		case EGL_CONTEXT_CLIENT_TYPE:
		{
			switch(psTls->ui32API)
			{
#if defined (SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
				case IMGEGL_API_OPENGL:
				{
					*value = EGL_OPENGL_API;

					break;
				}
#endif /* defined (SUPPORT_OPENGL) */
#if defined (SUPPORT_OPENVG) || defined(API_MODULES_RUNTIME_CHECKED)
				case IMGEGL_API_OPENVG:
				{
					*value = EGL_OPENVG_API;

					break;
				}
#endif /* defined (SUPPORT_OPENVG) */
#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
				case IMGEGL_API_OPENGLES:
				{
					*value = EGL_OPENGL_ES_API;

					break;
				}
#endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) */
			}

			break;
		}

		case EGL_CONTEXT_CLIENT_VERSION:
		{
			*value = psContext->eContextType;
			break;
		}

		case EGL_RENDER_BUFFER:
		{
			if (psContext->isCurrent)
			{
				switch (psTls->apsCurrentDrawSurface[psTls->ui32API]->type)
				{
					case EGL_SURFACE_PIXMAP:
					{
						*value = EGL_SINGLE_BUFFER;
						break;
					}
					case EGL_SURFACE_PBUFFER:
					{
						*value = EGL_BACK_BUFFER;
						break;
					}
					case EGL_SURFACE_WINDOW:
					{
						*value = EGL_BACK_BUFFER;
						break;
					}
				}
			}
			else
			{
				*value = EGL_NONE;
			}

			break;
		}
#if defined(SUPPORT_SGX_LOW_LATENCY_SCHEDULING)
		case EGL_CONTEXT_PRIORITY_LEVEL_IMG:
		{
			switch(psContext->contextMode.eContextPriority)
			{
				case SGX_CONTEXT_PRIORITY_HIGH:
					*value = EGL_CONTEXT_PRIORITY_HIGH_IMG;
					break;
				default:
				case SGX_CONTEXT_PRIORITY_MEDIUM:
					*value = EGL_CONTEXT_PRIORITY_MEDIUM_IMG;
					break;
				case SGX_CONTEXT_PRIORITY_LOW:
					*value = EGL_CONTEXT_PRIORITY_LOW_IMG;
					break;
			}
			break;
		}
#endif
		default:
		{
			psTls->lastError = EGL_BAD_ATTRIBUTE;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryContext);

			return EGL_FALSE;
		}

	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryContext);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglWaitGL
 *  PURPOSE    : Wait for OpenGL to complete rendering.
 *  PARAMETERS : None
 *  RETURNS    : EGL_TRUE - Success
 *               EGL_FALSE - Failure
 *
 ***********************************************************************/
IMG_EXPORT EGLBoolean IMGeglWaitGL(void)
{
	TLS psTls;
#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	KEGL_CONTEXT * psContext;
	KEGL_SURFACE * psSurface;
#endif
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglWaitGL"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglWaitGL);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitGL);

		return EGL_FALSE;
	}
#endif

#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	psContext = psTls->apsCurrentContext[psTls->ui32API];

	if (psContext==EGL_NO_CONTEXT)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitGL);

		return EGL_TRUE;
	}

	psSurface = psTls->apsCurrentDrawSurface[psTls->ui32API];

	if (psSurface == EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_CURRENT_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitGL);

		return EGL_FALSE;
	}

	/* Flush and wait for complete
	 * Only needed for pixmap - other types will be flushed at readpixel/swapbuffer)
	 */
	if(psSurface->type == EGL_SURFACE_PIXMAP)
	{
		IMG_EGLERROR eError;

		eError = IMG_EGL_NO_ERROR;

		if(psContext->eContextType == IMGEGL_CONTEXT_OPENGLES1)
		{
#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
#if defined(API_MODULES_RUNTIME_CHECKED)
			if(psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1])
#endif
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
				PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC)

				eError = psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC(psContext->hClientContext,
																			&psSurface->sRenderSurface,
																			IMG_FALSE,
																			IMG_FALSE,
																			IMG_TRUE);
			}
#endif
		}
#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
		else if (psContext->eContextType == IMGEGL_CONTEXT_OPENGL)
		{
#if defined(API_MODULES_RUNTIME_CHECKED)
			if(psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL])
#endif
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
				PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC)

				eError = psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC(psContext->hClientContext,
																		IMG_FALSE,
																		IMG_TRUE);
			}
		}
#endif
#if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
		else
		{
#if defined(API_MODULES_RUNTIME_CHECKED)
			if(psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2])
#endif
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOGLES2Functions)
				PVR_ASSERT(psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC)

				eError = psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC(psContext->hClientContext,
																			&psSurface->sRenderSurface,
																			IMG_FALSE,
																			IMG_FALSE,
																			IMG_TRUE);
			}
		}
#endif

		if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
		{
			psTls->lastError = EGL_CONTEXT_LOST;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitGL);

			return EGL_FALSE;
		}
	}
#endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(SUPPORT_OPENGL)*/

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitGL);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglWaitNative
 *  PURPOSE    : Wait for a native rendering engine to finish rendering.
 *  PARAMETERS : In:  engine - Native graphics engine to synchronise with.
 *  RETURNS    : EGL_TRUE - success.
 *               EGL_FALSE - failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglWaitNative(EGLint engine)
{
	TLS psTls;
	WSEGLError eError;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglWaitNative"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglWaitNative);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitNative);

		return EGL_FALSE;
	}
#endif

	if (psTls->apsCurrentContext[psTls->ui32API]==EGL_NO_CONTEXT)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitNative);

		return EGL_TRUE;
	}

	if (psTls->apsCurrentDrawSurface[psTls->ui32API] == EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_CURRENT_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitNative);

		return EGL_FALSE;
	}

	/*
	// Convert the engine value to something useful for the WSEGL module
	*/
	if (engine==EGL_CORE_NATIVE_ENGINE)
	{
		engine = WSEGL_DEFAULT_NATIVE_ENGINE;
	}
	else
	{
		PVR_DPF((PVR_DBG_WARNING, "IMGeglWaitNative: Letting engine value of %d fall through", engine));
	}

	EGLThreadLockWSEGL(psTls->apsCurrentDrawSurface[psTls->ui32API]->psDpy, psTls);

	switch(psTls->apsCurrentDrawSurface[psTls->ui32API]->type)
	{
		case EGL_SURFACE_WINDOW:
		{
			eError = psTls->apsCurrentDrawSurface[psTls->ui32API]->psDpy->pWSEGL_FT->pfnWSEGL_WaitNative(psTls->apsCurrentDrawSurface[psTls->ui32API]->u.window.hDrawable, engine);
			break;
		}
		case EGL_SURFACE_PIXMAP:
		{
			eError = psTls->apsCurrentDrawSurface[psTls->ui32API]->psDpy->pWSEGL_FT->pfnWSEGL_WaitNative(psTls->apsCurrentDrawSurface[psTls->ui32API]->u.pixmap.hDrawable, engine);
			break;
		}
		default:
		{
			eError = WSEGL_SUCCESS;
			break;
		}
	}

	EGLThreadUnlockWSEGL(psTls->apsCurrentDrawSurface[psTls->ui32API]->psDpy, psTls);

	if (eError==WSEGL_SUCCESS)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitNative);

		return EGL_TRUE;
	}

	psTls->lastError = EGL_BAD_PARAMETER;

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitNative);

	return EGL_FALSE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglSwapBuffers
 *  PURPOSE    : Present the current back buffer.
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  draw - Surface.
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglSwapBuffers(EGLDisplay eglDpy, EGLSurface draw)
{
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	IMG_EGLERROR eError;
	EGLint index;
	KEGL_CONTEXT *psContext;
	KEGL_SURFACE *psDrawSurface = (KEGL_SURFACE *)draw;
	IMG_BOOL bUseHWForWindowSync;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglSwapBuffers"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_INC_COUNT(IMGEGL_COUNTER_SWAP_BUFFERS_COUNT, 1);

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglSwapBuffers);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

		return EGL_FALSE;
	}
#endif


	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

		return EGL_FALSE;
	}

	if(!IsEGLSurface(psDpy, psDrawSurface))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

		return EGL_FALSE;
	}

	if (psDrawSurface==EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

		return EGL_FALSE;
	}

	if (psTls->apsCurrentDrawSurface[psTls->ui32API] != psDrawSurface)
	{
		/*
			If 'surface' is not bound to the calling thread's current context,
			an EGL_BAD_SURFACE error is generated.
		*/
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

		return EGL_FALSE;
	}

	psContext = psTls->apsCurrentContext[psTls->ui32API];

	if (psContext == EGL_NO_CONTEXT)
	{
		psTls->lastError = EGL_BAD_CONTEXT;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

		return EGL_FALSE;
	}

	bUseHWForWindowSync = psDrawSurface->psDpy->bUseHWForWindowSync;

#if defined(ANDROID)
	if (bUseHWForWindowSync)
	{
		EGLDrawableParams sParams;

		if (!KEGLGetDrawableParameters(psDrawSurface, &sParams, IMG_FALSE))
		{
			psTls->lastError = EGL_BAD_SURFACE;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

			return EGL_FALSE;
		}

		bUseHWForWindowSync = !sParams.bWaitForRender;
	}
#endif /* defined(ANDROID) */

	switch (psDrawSurface->type)
	{
		case EGL_SURFACE_WINDOW:
		{
#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
			if(
				(psContext->eContextType == IMGEGL_CONTEXT_OPENGLES1) &&
				psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1]
			)
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
				PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC)

				eError = psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC(psContext->hClientContext,
																			&psDrawSurface->sRenderSurface,
																			IMG_FALSE,
																			IMG_TRUE, 
																			(IMG_BOOL)!bUseHWForWindowSync);
			}
			else
#endif
#if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
			if(
				(psContext->eContextType == IMGEGL_CONTEXT_OPENGLES2) &&
				psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2]
			)
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOGLES2Functions)
				PVR_ASSERT(psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC)

				eError = psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC(psContext->hClientContext,
																			&psDrawSurface->sRenderSurface,
																			IMG_FALSE,
																			IMG_TRUE, 
																			(IMG_BOOL)!bUseHWForWindowSync);
			}
			else
#endif
#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
			if(
				(psContext->eContextType == IMGEGL_CONTEXT_OPENGL) &&
				psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL]
			)
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
				PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC)

				eError = psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC(psContext->hClientContext,
																 IMG_TRUE, (IMG_BOOL)!bUseHWForWindowSync);
			}
			else
#endif
#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
			if(
				(psContext->eContextType == IMGEGL_CONTEXT_OPENVG) &&
				psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG]
			)
			{
				PVR_ASSERT(psTls->psGlobalData->bHaveOVGFunctions)
				PVR_ASSERT(psTls->psGlobalData->spfnOVG.pfnOVGFlushBuffersGC)

				eError = psTls->psGlobalData->spfnOVG.pfnOVGFlushBuffersGC(psContext->hClientContext,
															 IMG_TRUE, (IMG_BOOL)!bUseHWForWindowSync);
			}
			else
#endif
			{
				eError = IMG_EGL_GENERIC_ERROR;

				PVR_DPF((PVR_DBG_WARNING,"IMGeglSwapBuffers: Invalid client API"));
			}

			if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

				return EGL_FALSE;
			}

			/* We may have lost a scene (from power management). Just omit the swap */
			if (eError == IMG_EGL_NO_ERROR)
			{
				WSEGLError eWSEGLError;

				EGLThreadLockWSEGL(psDpy, psTls);

				eWSEGLError = psDpy->pWSEGL_FT->pfnWSEGL_SwapDrawable(psDrawSurface->u.window.hDrawable,
																	 psDrawSurface->u.window.ui32SwapCount);


				if (eWSEGLError != WSEGL_SUCCESS)
				{
					EGLThreadUnlockWSEGL(psDpy, psTls);

					psTls->lastError = EGL_BAD_NATIVE_WINDOW;

					IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

					return EGL_FALSE;
				}

				EGLThreadUnlockWSEGL(psDpy, psTls);

				EGLThreadLock(psTls);
				psDrawSurface->u.window.ui32SwapCount++;
				EGLThreadUnlock(psTls);
			}

			break;
		}
		case EGL_SURFACE_PIXMAP:
		case EGL_SURFACE_PBUFFER:
		{
			/* no effect on non window surfaces */
			break;
		}
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapBuffers);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglCopyBuffers
 *  PURPOSE    : Copy a render to a native pixmap.
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  eglSurface - Surface.
 *               In:  target - Native pixmap
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglCopyBuffers(EGLDisplay eglDpy,
										EGLSurface eglSurface,
										NativePixmapType target)
{
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	IMG_EGLERROR eError;
	EGLint index;
	KEGL_CONTEXT *psContext;
	KEGL_SURFACE *psSurface = (KEGL_SURFACE *)eglSurface;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglCopyBuffers"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglCopyBuffers);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

		return EGL_FALSE;
	}

	if (psSurface==EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

		return EGL_FALSE;
	}

	if(!IsEGLSurface(psDpy, psSurface))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

		return EGL_FALSE;
	}

	if (psTls->apsCurrentReadSurface[psTls->ui32API] != psSurface)
	{
		/*
			If 'surface' is not bound to the calling thread's current context,
			an EGL_BAD_SURFACE error is	generated.
		*/
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

		return EGL_FALSE;

	}

	psContext = psTls->apsCurrentContext[psTls->ui32API];

	if (psContext == EGL_NO_CONTEXT)
	{
		psTls->lastError = EGL_BAD_CONTEXT;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

		return EGL_FALSE;
	}

#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
	if(
		(psContext->eContextType == IMGEGL_CONTEXT_OPENGLES1) &&
		psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1]
	)
	{
		PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
		PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC)

		eError = psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC(psContext->hClientContext,
																		&psSurface->sRenderSurface,
																		IMG_FALSE,
																		IMG_FALSE,
																		IMG_TRUE);
	}
	else
#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
	if(
		(psContext->eContextType == IMGEGL_CONTEXT_OPENGLES2) &&
		psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2]
	)
	{
		PVR_ASSERT(psTls->psGlobalData->bHaveOGLES2Functions)
		PVR_ASSERT(psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC)

		eError = psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC(psContext->hClientContext,
																		&psSurface->sRenderSurface,
																		IMG_FALSE,
																		IMG_FALSE,
																		IMG_TRUE);
	}
	else
#endif /* defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	if(
		(psContext->eContextType == IMGEGL_CONTEXT_OPENGL) &&
		psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL]
	)
	{
		PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
		PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC)

		eError = psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC(psContext->hClientContext,
														IMG_FALSE,
														IMG_TRUE);
	}
	else
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
	if(
		(psContext->eContextType == IMGEGL_CONTEXT_OPENVG) &&
		psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG]
	)
	{
		PVR_ASSERT(psTls->psGlobalData->bHaveOVGFunctions)
		PVR_ASSERT(psTls->psGlobalData->spfnOVG.pfnOVGFlushBuffersGC)

		eError = psTls->psGlobalData->spfnOVG.pfnOVGFlushBuffersGC(psContext->hClientContext, IMG_FALSE, IMG_TRUE);
	}
	else
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED) */
	{
		eError = IMG_EGL_GENERIC_ERROR;

		PVR_DPF((PVR_DBG_WARNING,"IMGeglCopyBuffers: Invalid client API"));
	}

	switch (eError)
	{
		case IMG_EGL_NO_ERROR:
		{
			/* success */
			break;
		}
		case IMG_EGL_MEMORY_INVALID_ERROR:
		{
			psTls->lastError = EGL_CONTEXT_LOST;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

			return EGL_FALSE;
		}
		default:
		{
			psTls->lastError = EGL_BAD_ALLOC;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

			return EGL_FALSE;
		}
	}

	/* We may have lost a scene (from power management). Just omit the copy */
	if (eError == IMG_EGL_NO_ERROR)
	{
		EGLThreadLockWSEGL(psDpy, psTls);

		switch(psSurface->type)
		{
			case EGL_SURFACE_PBUFFER:
			{
				IMG_UINT32 ui32StrideInPixels;
				WSEGLPixelFormat ePixelFormat;
				WSEGLError eWSError;

				ePixelFormat = aConvertPVRPixelFormatToWSEGL[psSurface->u.pbuffer.ePixelFormat];

				ui32StrideInPixels = psSurface->u.pbuffer.ui32ByteStride >>
									 aWSEGLPixelFormatBytesPerPixelShift[ePixelFormat];

				eWSError = psDpy->pWSEGL_FT->pfnWSEGL_CopyFromPBuffer(psSurface->u.pbuffer.psMemInfo->pvLinAddr,
																	  psSurface->u.pbuffer.ui32PixelWidth,
																	  psSurface->u.pbuffer.ui32PixelHeight,
																	  ui32StrideInPixels,
																	  ePixelFormat,
																	  target);

				switch(eWSError)
				{
					case WSEGL_OUT_OF_MEMORY:
					{
						psTls->lastError = EGL_BAD_ALLOC;
						break;
					}
					case WSEGL_BAD_NATIVE_PIXMAP:
					{
						psTls->lastError = EGL_BAD_NATIVE_PIXMAP;

						break;
					}
					case WSEGL_BAD_MATCH:
					{
						psTls->lastError = EGL_BAD_MATCH;

						break;
					}
					default:
					{
						break;
					}
				}

				break;
			}
			case EGL_SURFACE_PIXMAP:
			{
				WSEGLError eWSError;

				eWSError = psDpy->pWSEGL_FT->pfnWSEGL_CopyFromDrawable(psSurface->u.pixmap.hDrawable, target);

				switch(eWSError)
				{
					case WSEGL_BAD_NATIVE_PIXMAP:
					{
						psTls->lastError = EGL_BAD_NATIVE_PIXMAP;

						break;
					}
					case WSEGL_BAD_NATIVE_WINDOW:
					{
						psTls->lastError = EGL_BAD_NATIVE_WINDOW;

						break;
					}
					case WSEGL_BAD_MATCH:
					{
						psTls->lastError = EGL_BAD_MATCH;

						break;
					}
					default:
					{
						break;
					}
				}

				break;
			}
			default:
			{
				WSEGLError eWSError;

				eWSError = psDpy->pWSEGL_FT->pfnWSEGL_CopyFromDrawable(psSurface->u.window.hDrawable, target);

				switch(eWSError)
				{
					case WSEGL_BAD_NATIVE_PIXMAP:
					{
						psTls->lastError = EGL_BAD_NATIVE_PIXMAP;

						break;
					}
					case WSEGL_BAD_NATIVE_WINDOW:
					{
						psTls->lastError = EGL_BAD_NATIVE_WINDOW;

						break;
					}
					case WSEGL_BAD_MATCH:
					{
						psTls->lastError = EGL_BAD_MATCH;

						break;
					}
					default:
					{
						break;
					}
				}

				break;
			}
		}

		EGLThreadUnlockWSEGL(psDpy, psTls);
	}

	if (psTls->lastError!=EGL_SUCCESS)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

		return EGL_FALSE;
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCopyBuffers);

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglSwapInterval
 *  PURPOSE    : Define the number of swap intervals between presents
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  interval - interval number.
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglSwapInterval(EGLDisplay eglDpy, EGLint interval)
{
	KEGL_DISPLAY *psDpy;
	KEGL_SURFACE * pCurrentDrawSurface;
	KEGL_CONTEXT * pCurrentContext;
	TLS psTls;
	EGLint index;
	EGLint nTemp;
	EGLBoolean bRetValue;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF ((PVR_DBG_CALLTRACE, "IMGeglSwapInterval"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglSwapInterval);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapInterval);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapInterval);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapInterval);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapInterval);

		return EGL_FALSE;
	}

	pCurrentContext = psTls->apsCurrentContext[psTls->ui32API];

	if (pCurrentContext == EGL_NO_CONTEXT)
	{
		psTls->lastError = EGL_BAD_CONTEXT;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapInterval);

		return EGL_FALSE;
	}

	pCurrentDrawSurface = psTls->apsCurrentDrawSurface[psTls->ui32API];

	if (pCurrentDrawSurface == EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapInterval);

		return EGL_FALSE;
	}

	/*
		The specification requires that the requested interval is silently
		clamped to the implementations maximum and minimum supported interval.
	*/
	nTemp = CFGC_GetAttrib(pCurrentContext->psCfg, EGL_MAX_SWAP_INTERVAL);
	if (interval >= nTemp)
	{
		interval = nTemp;
	}
	else
	{
		nTemp = CFGC_GetAttrib(pCurrentContext->psCfg, EGL_MIN_SWAP_INTERVAL);
		if (interval <= nTemp)
		{
			interval = nTemp;
		}
	}

	bRetValue = EGL_TRUE;

	if (pCurrentDrawSurface->type == EGL_SURFACE_WINDOW)
	{
		EGLThreadLockWSEGL(psDpy, psTls);

		if(psDpy->pWSEGL_FT->pfnWSEGL_SwapControlInterval(psTls->apsCurrentDrawSurface[psTls->ui32API]->u.window.hDrawable, interval) != WSEGL_SUCCESS)
		{
			PVR_DPF((PVR_DBG_ERROR,"IMGeglSwapInterval: unexpected error code"));

			psTls->lastError = EGL_BAD_ALLOC;/* arbitrary choice */
			bRetValue = EGL_FALSE;
		}

		EGLThreadUnlockWSEGL(psDpy, psTls);
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSwapInterval);

	return bRetValue;
}


/***********************************************************************
 *
 *  FUNCTION   : eglSurfaceAttrib
 *  PURPOSE    : Sets attributes of a surface
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  eglSurface - Surface
 *               In:  attribute - Surface attribute
 *               In:  value - Value of surface attribute
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglSurfaceAttrib(EGLDisplay eglDpy,
										  EGLSurface eglSurface,
										  EGLint attribute,
										  EGLint value)
{
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	EGLint index;
	KEGL_SURFACE *psSurface = (KEGL_SURFACE *)eglSurface;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	EGLint renderableBits = 0;

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglSurfaceAttrib"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglSurfaceAttrib);

#if defined(API_MODULES_RUNTIME_CHECKED)
	renderableBits = EGL_OPENGL_ES_BIT|EGL_OPENGL_ES2_BIT;

	if (psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL])
	{
		renderableBits |= EGL_OPENGL_BIT;
	}
#else /* defined(API_MODULES_RUNTIME_CHECKED) */
#   if defined(SUPPORT_OPENGL)
	renderableBits = EGL_OPENGL_ES_BIT|EGL_OPENGL_BIT|EGL_OPENGL_ES2_BIT;
#   else
	renderableBits = EGL_OPENGL_ES_BIT|EGL_OPENGL_ES2_BIT;
#   endif
#endif /* defined(API_MODULES_RUNTIME_CHECKED) */

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

		return EGL_FALSE;
	}

	if(!IsEGLSurface(psDpy, psSurface))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

		return EGL_FALSE;
	}

	if (psSurface==EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

		return EGL_FALSE;
	}

	switch(attribute)
	{
		case EGL_MIPMAP_LEVEL:
		{
			/* Check the config supports OpenGL(ES) */
			if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_RENDERABLE_TYPE) & renderableBits))
			{
				psTls->lastError = EGL_BAD_PARAMETER;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

				return EGL_FALSE;
			}

			if(psSurface->type==EGL_SURFACE_PBUFFER)
			{
				psSurface->u.pbuffer.ui32Level = value;
			}

			break;
		}
		case EGL_SWAP_BEHAVIOR:
		{
			switch(value)
			{
				case EGL_BUFFER_PRESERVED:
				{
					if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_SWAP_BEHAVIOR_PRESERVED_BIT))
					{
						psTls->lastError = EGL_BAD_MATCH;

						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

						return EGL_FALSE;
					}

					psSurface->iSwapBehaviour = EGL_BUFFER_PRESERVED;

					break;
				}
				case EGL_BUFFER_DESTROYED:
				{
					psSurface->iSwapBehaviour = EGL_BUFFER_DESTROYED;

					break;
				}
				default:
				{
bad_attrib:
					psTls->lastError = EGL_BAD_ATTRIBUTE;

					IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

					return EGL_FALSE;
				}
			}
			break;
		}
		case EGL_MULTISAMPLE_RESOLVE:
		{
			switch(value)
			{
				case EGL_MULTISAMPLE_RESOLVE_BOX:
				{
					if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_MULTISAMPLE_RESOLVE_BOX_BIT))
					{
						psTls->lastError = EGL_BAD_MATCH;

						IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglSurfaceAttrib);

						return EGL_FALSE;
					}

					psSurface->iMultiSampleResolve = EGL_MULTISAMPLE_RESOLVE_BOX;

					break;
				}
				case EGL_MULTISAMPLE_RESOLVE_DEFAULT:
				{
					psSurface->iMultiSampleResolve = EGL_MULTISAMPLE_RESOLVE_DEFAULT;

					break;
				}
				default:
				{
					goto bad_attrib;
				}
			}
			break;
		}
		default:
		{
			goto bad_attrib;
		}
	}

	return EGL_TRUE;
}


/***********************************************************************
 *
 *  FUNCTION   : eglBindTexImage
 *  PURPOSE    : Binds an egl surface as a texture
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  eglSurface - Surface
 *               In:  buffer - buffer of surface
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglBindTexImage(EGLDisplay eglDpy,
										 EGLSurface eglSurface,
										 EGLint buffer)
{
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	EGLint index;
#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	IMG_EGLERROR eError = IMG_EGL_NO_ERROR;
	IMG_BOOL bWaitForHW = IMG_FALSE;
	KEGL_CONTEXT *psFlushContext = IMG_NULL;
#endif
	KEGL_CONTEXT *psContext;

	KEGL_SURFACE *psSurface = (KEGL_SURFACE *)eglSurface;
#if defined(EGL_EXTENSION_RENDER_TO_TEXTURE)
	IMG_BOOL bReturnVal = IMG_FALSE;
#endif /*  defined(EGL_EXTENSION_RENDER_TO_TEXTURE) */
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglBindTexImage"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglBindTexImage);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}

	if(!IsEGLSurface(psDpy, psSurface))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}

	if (psSurface==EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}

	if(psSurface->u.pbuffer.eTextureFormat == PVRSRV_PIXEL_FORMAT_UNKNOWN)
	{
		psTls->lastError = EGL_BAD_MATCH;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}

	if(psSurface->type != EGL_SURFACE_PBUFFER || !psSurface->u.pbuffer.bTexture)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}

	if(buffer != EGL_BACK_BUFFER)
	{
		psTls->lastError = EGL_BAD_PARAMETER;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}

	psContext = psTls->apsCurrentContext[psTls->ui32API];

#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)

	/* Bind has no effect */
	if(psContext == EGL_NO_CONTEXT)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_TRUE;
	}

	if(psSurface->currentCount)
	{
		/* The pbuffer surface is currently bound to this thread, so flush (ie kick and don't wait) */
		if(psSurface == psTls->apsCurrentDrawSurface[psTls->ui32API])
		{
			psFlushContext = psContext;
			bWaitForHW = IMG_FALSE;
		}
		else
		{
			/* The pbuffer surface is currently bound to another thread. Find the context in that thread and
			* use it to finish (ie kick and wait).
			*/
			psFlushContext = _FindContextByThreadID(psDpy, psSurface->boundThread);
			bWaitForHW = IMG_TRUE;
		}
	}

	if(psFlushContext)
	{
#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psContext->eContextType == IMGEGL_CONTEXT_OPENGLES1) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC(psFlushContext->hClientContext,
																		   IMG_NULL,
																		   IMG_FALSE,
																		   IMG_FALSE,
																		   bWaitForHW);
		}
		else
#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
		if(
			(psContext->eContextType == IMGEGL_CONTEXT_OPENGL) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL]
		)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC(psFlushContext->hClientContext,
																	  IMG_FALSE,
																	  bWaitForHW);
		}
		else
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

		{
			/* Handle other APIs  */
			eError = IMG_EGL_GENERIC_ERROR;
			PVR_DPF((PVR_DBG_WARNING,"IMGeglBindTexImage: Invalid client context type"));
		}
	}

	switch (eError)
	{
		case IMG_EGL_NO_ERROR:
		{
			/* success */
			break;
		}
		case IMG_EGL_MEMORY_INVALID_ERROR:
		{
			psTls->lastError = EGL_CONTEXT_LOST;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

			return EGL_FALSE;
		}
		default:
		{
			psTls->lastError = EGL_BAD_ALLOC;

			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

			return EGL_FALSE;
		}
	}

#if defined(EGL_EXTENSION_RENDER_TO_TEXTURE)

#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
	if(
		(psContext->eContextType == IMGEGL_CONTEXT_OPENGLES1) &&
		psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1]
	)
	{
		PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
		PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESBindTexImage)

		bReturnVal = psTls->psGlobalData->spfnOGLES1.pfnGLESBindTexImage(psContext->hClientContext, psSurface, &psSurface->u.pbuffer.hTexture);
	}
#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	else
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)*/
#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)*/

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	if(
		(psContext->eContextType == IMGEGL_CONTEXT_OPENGL) &&
		psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1]
	)
	{
		PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
		PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLBindTexImage)

		bReturnVal = psTls->psGlobalData->spfnOGL.pfnGLBindTexImage(psContext->hClientContext, psSurface, &psSurface->u.pbuffer.hTexture);
	}
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

	if(bReturnVal != IMG_TRUE)
	{
		psTls->lastError = EGL_BAD_ACCESS;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

		return EGL_FALSE;
	}

#endif /* defined(EGL_EXTENSION_RENDER_TO_TEXTURE) */

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

	return EGL_TRUE;

#else /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

	psTls->lastError = EGL_BAD_SURFACE;

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindTexImage);

	return bReturnVal;

#endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */
}


/***********************************************************************
 *
 *  FUNCTION   : eglReleaseTexImage
 *  PURPOSE    : Releases an egl surface bound as a texture
 *  PARAMETERS : In:  eglDpy - Display.
 *               In:  eglSurface - Surface
 *               In:  buffer - buffer of surface
 *  RETURNS    : EGL_TRUE - Success.
 *               EGL_FALSE - Failure.
 *
 **********************************************************************/
IMG_EXPORT EGLBoolean IMGeglReleaseTexImage(EGLDisplay eglDpy,
											EGLSurface eglSurface,
											EGLint buffer)
{
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	EGLint index;
	KEGL_SURFACE *psSurface = (KEGL_SURFACE *)eglSurface;
#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
#if defined(EGL_EXTENSION_RENDER_TO_TEXTURE)
	KEGL_CONTEXT *psContext;
#endif /*  defined(EGL_EXTENSION_RENDER_TO_TEXTURE) */
#endif
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglReleaseTexImage"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglReleaseTexImage);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_FALSE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_FALSE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_FALSE;
	}

	if(!IsEGLSurface(psDpy, psSurface))
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_FALSE;
	}

	if (psSurface==EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_FALSE;
	}

	if(psSurface->type != EGL_SURFACE_PBUFFER || !psSurface->u.pbuffer.hTexture)
	{
		psTls->lastError = EGL_BAD_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_FALSE;
	}

	if(psSurface->u.pbuffer.eTextureFormat == PVRSRV_PIXEL_FORMAT_UNKNOWN)
	{
		psTls->lastError = EGL_BAD_MATCH;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_FALSE;
	}

	if(buffer != EGL_BACK_BUFFER)
	{
		psTls->lastError = EGL_BAD_PARAMETER;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_FALSE;
	}

#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)

#if defined(EGL_EXTENSION_RENDER_TO_TEXTURE)

	psContext = psTls->apsCurrentContext[psTls->ui32API];

	if(psContext == EGL_NO_CONTEXT)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

		return EGL_TRUE;
	}

#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
	if(
		(psContext->eContextType == IMGEGL_CONTEXT_OPENGLES1) &&
		psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1]
	)
	{
		if(psContext->hClientContext && psSurface->u.pbuffer.hTexture)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESReleaseTexImage)

			psTls->psGlobalData->spfnOGLES1.pfnGLESReleaseTexImage(psContext->hClientContext, psSurface, &psSurface->u.pbuffer.hTexture);
		}
	}

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	else
#endif

#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	if(
		(psContext->eContextType == IMGEGL_CONTEXT_OPENGL) &&
		psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL]
	)
	{
		if(psContext->hClientContext && psSurface->u.pbuffer.hTexture)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLReleaseTexImage)

			psTls->psGlobalData->spfnOGL.pfnGLReleaseTexImage(psContext->hClientContext, psSurface, &psSurface->u.pbuffer.hTexture);
		}
	}
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */


#endif /* defined(EGL_EXTENSION_RENDER_TO_TEXTURE) */

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

	return IMG_TRUE;

#else /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

	psTls->lastError = EGL_BAD_SURFACE;

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseTexImage);

	return EGL_FALSE;

#endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(SUPPORT_OPENGL)*/
}


/***********************************************************************
 *
 *  FUNCTION   : eglCreatePbufferFromClientBuffer
 *  PURPOSE    : Create a Pbuffer surface from a client buffer (VGImage)
 *  PARAMETERS : In:  eglDpy - Display.
 *				 In:  buftype - type of client buffer
 *				 In:  buffer - client buffer handle
 *               In:  eglCfg - Configuration.
 *               In:  pAttribList - Required attributes.
 *  RETURNS    : Created surface or EGL_NO_SURFACE.
 *
 **********************************************************************/
IMG_EXPORT EGLSurface IMGeglCreatePbufferFromClientBuffer(EGLDisplay eglDpy,
														  EGLenum buftype,
														  EGLClientBuffer buffer,
														  EGLConfig eglCfg,
														  const EGLint *pAttribList)
{
	EGLint index;
	KEGL_SURFACE *psSurface;
	KEGL_DISPLAY *psDpy;
	TLS psTls;
	IMG_UINT32 ui32ByteStride = 0, ui32PixelWidth = 0, ui32PixelHeight = 0;
	PVRSRV_PIXEL_FORMAT	ePixelFormat = PVRSRV_PIXEL_FORMAT_UNKNOWN;
	PVRSRV_CLIENT_MEM_INFO *psMemInfo = IMG_NULL;
	PVRSRV_PIXEL_FORMAT eTextureFormat;
	IMG_BOOL bMipMap;
	IMG_BOOL bTextureTarget;
	EGLint renderableBits = 0;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_UNREFERENCED_PARAMETER(pAttribList);

#if !(defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED))
	PVR_UNREFERENCED_PARAMETER(buffer);
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglCreatePbufferFromClientBuffer"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglCreatePbufferFromClientBuffer);

#if defined(API_MODULES_RUNTIME_CHECKED)
	renderableBits = EGL_OPENGL_ES_BIT|EGL_OPENGL_ES2_BIT;

	if (psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL])
	{
		renderableBits |= EGL_OPENGL_BIT;
	}
#else
#   if defined(SUPPORT_OPENGL)
	renderableBits = EGL_OPENGL_ES_BIT|EGL_OPENGL_BIT|EGL_OPENGL_ES2_BIT;
#   else
	renderableBits = EGL_OPENGL_ES_BIT|EGL_OPENGL_ES2_BIT;
#   endif
#endif

	if(EGL_OPENVG_IMAGE != buftype)
	{
		/* Currently only VG images are supported */
		psTls->lastError = EGL_BAD_PARAMETER;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferFromClientBuffer);

		return EGL_NO_SURFACE;
	}

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferFromClientBuffer);

		return EGL_FALSE;
	}
#endif

	if (eglDpy==EGL_NO_DISPLAY)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferFromClientBuffer);

		return EGL_NO_SURFACE;
	}

	index = EGLDISPLAY_TO_SLOT_INDEX(eglDpy);

	if(index >= psTls->psGlobalData->dpyCount || index < 0)
	{
		psTls->lastError = EGL_BAD_DISPLAY;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferFromClientBuffer);

		return EGL_NO_SURFACE;
	}

	psDpy = &psTls->psGlobalData->asDisplay[index];

	if (!psDpy->isInitialised)
	{
		psTls->lastError = EGL_NOT_INITIALIZED;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferFromClientBuffer);

		return EGL_NO_SURFACE;
	}

	psSurface = EGLCalloc(sizeof *psSurface);

	if (psSurface == 0)
	{
		goto bad_alloc;
	}

	/* Sanity checks: Should be zeroed by Calloc */
	PVR_ASSERT(psSurface->currentCount == 0);
	PVR_ASSERT(psSurface->refCount == 0);
	PVR_ASSERT(psSurface->boundThread  == 0);

	psSurface->isDeleting   = EGL_FALSE;
	psSurface->type         = EGL_SURFACE_PBUFFER;
	psSurface->psDpy        = psDpy;

	psTls->lastError = CFG_GenerateVariant(psDpy, (KEGL_CONFIG_INDEX)eglCfg, &psSurface->psCfg);

	if (psTls->lastError != EGL_SUCCESS)
	{
		goto cleanup_exit;
	}


#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
	if(
		(psTls->ui32API == IMGEGL_API_OPENVG) &&
		psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG]
	)
	{
		PVR_ASSERT(psTls->psGlobalData->bHaveOVGFunctions)
		PVR_ASSERT(psTls->psGlobalData->spfnOVG.pfnOVGWrapImageAsRenderSurface)

		psSurface->sRenderSurface.hVGClientBuffer = buffer;

		if (psTls->apsCurrentContext[psTls->ui32API] == IMG_NULL)
		{
			psSurface->sRenderSurface.hVGClientBuffer   = IMG_NULL;

			psTls->lastError = EGL_BAD_ACCESS;
			goto cleanup_exit;
		}

		psTls->lastError = psTls->psGlobalData->spfnOVG.pfnOVGWrapImageAsRenderSurface(
																	   psTls->apsCurrentContext[psTls->ui32API]->hClientContext,
																	   &psSurface->sRenderSurface,
																	   &psSurface->sRenderSurface.hVGClientBuffer,
																	   CFGC_GetAttrib(psSurface->psCfg, EGL_RED_SIZE),
																	   CFGC_GetAttrib(psSurface->psCfg, EGL_GREEN_SIZE),
																	   CFGC_GetAttrib(psSurface->psCfg, EGL_BLUE_SIZE),
																	   CFGC_GetAttrib(psSurface->psCfg, EGL_ALPHA_SIZE),
																	   &ui32ByteStride,
																	   &ui32PixelWidth,
																	   &ui32PixelHeight,
																	   &ePixelFormat,
																	   &psMemInfo);
	}
	else
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) */
	{
		PVR_DPF((PVR_DBG_WARNING,"IMGeglCreatePbufferFromClientBuffer: Invalid client API"));

		psTls->lastError = EGL_BAD_MATCH;
	}

	if (psTls->lastError != EGL_SUCCESS)
	{
		goto cleanup_exit;
	}

	eTextureFormat  = PVRSRV_PIXEL_FORMAT_UNKNOWN;
	bTextureTarget  = IMG_FALSE;
	bMipMap         = IMG_FALSE;

	if (pAttribList!=IMG_NULL)
	{
		while (*pAttribList!=EGL_NONE)
		{
			EGLint attrib = *pAttribList++;
			EGLint value;

			value = *pAttribList++;

			switch (attrib)
			{
				case EGL_TEXTURE_TARGET:
				{
					/* Check the config supports OpenGL(ES) */
					if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_RENDERABLE_TYPE) & renderableBits))
					{
						goto bad_attrib;
					}

					switch(value)
					{
						case EGL_NO_TEXTURE:
						{
							bTextureTarget = IMG_FALSE;

							break;
						}
						case EGL_TEXTURE_2D:
						{
							bTextureTarget = IMG_TRUE;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}

					break;
				}
				case EGL_TEXTURE_FORMAT:
				{
					/* Check the config supports OpenGL(ES) */
					if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_RENDERABLE_TYPE) & renderableBits))
					{
						goto bad_attrib;
					}

					switch(value)
					{
						case EGL_NO_TEXTURE:
						{
							eTextureFormat = PVRSRV_PIXEL_FORMAT_UNKNOWN;

							break;
						}
						case EGL_TEXTURE_RGB:
						{
							eTextureFormat = PVRSRV_PIXEL_FORMAT_RGB565;

							break;
						}
						case EGL_TEXTURE_RGBA:
						{
							eTextureFormat = PVRSRV_PIXEL_FORMAT_ARGB8888;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}

					break;
				}
				case EGL_MIPMAP_TEXTURE:
				{
					/* Check the config supports OpenGL(ES) */
					if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_RENDERABLE_TYPE) & renderableBits))
					{
						goto bad_attrib;
					}

					switch(value)
					{
						case EGL_FALSE:
						{
							bMipMap = IMG_FALSE;

							break;
						}
						case EGL_TRUE:
						{
							bMipMap = IMG_TRUE;

							break;
						}
						default:
						{
							goto bad_attrib;
						}
					}

					break;
				}
				default:
				{
					goto bad_attrib;
				}
			}
		}
	}


	if (!(CFGC_GetAttrib(psSurface->psCfg, EGL_SURFACE_TYPE) & EGL_PBUFFER_BIT))
	{
		goto bad_match;
	}

	if((eTextureFormat != PVRSRV_PIXEL_FORMAT_UNKNOWN) && !bTextureTarget)
	{
		goto bad_match;
	}

	if(bTextureTarget && (eTextureFormat == PVRSRV_PIXEL_FORMAT_UNKNOWN))
	{
		goto bad_match;
	}

	if(eTextureFormat)
	{
		IMG_UINT32 ui32SizeLog2;
		IMG_UINT32 ui32TexSize;

		if(eTextureFormat == PVRSRV_PIXEL_FORMAT_RGB565)
		{
			if (CFGC_GetAttrib(psSurface->psCfg, EGL_BIND_TO_TEXTURE_RGB) == IMG_FALSE)
			{
				goto bad_match;
			}
		}
		else
		{
			if (CFGC_GetAttrib(psSurface->psCfg, EGL_BIND_TO_TEXTURE_RGBA) == IMG_FALSE)
			{
				goto bad_match;
			}
		}

		/* We don't support mipmapped render targets */
		if(bMipMap)
		{
			goto bad_alloc;
		}

		ui32SizeLog2 = 0;
		ui32TexSize  = 1;

		/* find the bounding texture sizes (power of 2) */
		while(ui32TexSize < ui32PixelWidth)
		{
			ui32TexSize <<= 1;

			ui32SizeLog2++;
		}

		if(ui32TexSize != ui32PixelWidth)
		{
			goto bad_match;
		}

		if(ui32SizeLog2 < IMG_MIN_RENDER_TEXTURE_LEVEL || ui32SizeLog2 > IMG_MAX_TEXTURE_MIPMAP_LEVELS)
		{
			goto bad_match;
		}

		ui32SizeLog2 = 0;
		ui32TexSize  = 1;

		/* find the bounding texture sizes (power of 2) */
		while(ui32TexSize < ui32PixelHeight)
		{
			ui32TexSize <<= 1;

			ui32SizeLog2++;
		}

		if(ui32TexSize != ui32PixelHeight)
		{
			goto bad_match;
		}

		if(ui32SizeLog2 < IMG_MIN_RENDER_TEXTURE_LEVEL || ui32SizeLog2 > IMG_MAX_TEXTURE_MIPMAP_LEVELS)
		{
			goto bad_match;
		}
	}

	psSurface->u.pbuffer.ui32ByteStride = ui32ByteStride;
	psSurface->u.pbuffer.ui32PixelWidth = ui32PixelWidth;
	psSurface->u.pbuffer.ui32PixelHeight= ui32PixelHeight;
	psSurface->u.pbuffer.ePixelFormat   = ePixelFormat;
	psSurface->u.pbuffer.psMemInfo      = psMemInfo;
	psSurface->u.pbuffer.eTextureFormat = eTextureFormat;
	psSurface->u.pbuffer.bTexture       = bTextureTarget;
	psSurface->u.pbuffer.bMipMap        = bMipMap;
	psSurface->u.pbuffer.ui32Level      = 0;
	psSurface->u.pbuffer.hTexture       = 0;
	psSurface->u.pbuffer.bLargest       = IMG_FALSE;

	if(!SRV_CreateSurface(&psTls->psGlobalData->sSysContext, psSurface))
	{
		goto bad_alloc;
	}

	EGLThreadLock(psTls);

	/* chain this surface onto the displays surface list */
	psSurface->psNextSurface = psDpy->psHeadSurface;

	psDpy->psHeadSurface = psSurface;

	EGLThreadUnlock(psTls);

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferFromClientBuffer);

	return psSurface;

bad_alloc:
	psTls->lastError = EGL_BAD_ALLOC;
	goto cleanup_exit;

bad_match:
	psTls->lastError = EGL_BAD_MATCH;
	goto cleanup_exit;

bad_attrib:
	psTls->lastError = EGL_BAD_ATTRIBUTE;

cleanup_exit:
	if (psSurface)
	{
#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
		if(psSurface->sRenderSurface.hVGClientBuffer)
		{
			PVR_ASSERT(psTls->psGlobalData->bHaveOVGFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOVG.pfnOVGUnWrapImage)

			psTls->psGlobalData->spfnOVG.pfnOVGUnWrapImage(psSurface->sRenderSurface.hVGClientBuffer);
		}
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED) */

		CFGC_Unlink(psSurface->psCfg); /* CFGC_Unlink does the null check */

		EGLFree(psSurface);
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglCreatePbufferFromClientBuffer);

	return EGL_NO_SURFACE;
}


/***********************************************************************************
 Function Name      : eglBindAPI
 Inputs             :
 Outputs            :
 Returns            :
 Description        :
************************************************************************************/
IMG_EXPORT EGLBoolean IMGeglBindAPI(EGLenum api)
{
	TLS psTls;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglBindAPI"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_NONE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglBindAPI);

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindAPI);

		return EGL_FALSE;
	}
#endif

#	if defined(API_MODULES_RUNTIME_CHECKED)
	{
		if(
			(api == EGL_OPENGL_ES_API) &&
			(
				psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1] ||
				psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2]
			)
		)
		{
			psTls->ui32API = IMGEGL_API_OPENGLES;
			psTls->lastError = EGL_SUCCESS;
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindAPI);
			return EGL_TRUE;
		}
		else if(
			(api == EGL_OPENGL_API) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGL]
		)
		{
			psTls->ui32API = IMGEGL_API_OPENGL;
			psTls->lastError = EGL_SUCCESS;
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindAPI);
			return EGL_TRUE;
		}
		else if(
			(api == EGL_OPENVG_API) &&
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENVG]
		)
		{
			psTls->ui32API = IMGEGL_API_OPENVG;
			psTls->lastError = EGL_SUCCESS;
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindAPI);
			return EGL_TRUE;
		}
		else
		{
			PVR_DPF((PVR_DBG_WARNING, "IMGeglBindAPI: Invalid client API: %x", api));
			psTls->lastError = EGL_BAD_PARAMETER;
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindAPI);
			return EGL_FALSE;
		}
	}
#	else /* defined(API_MODULES_RUNTIME_CHECKED) */
	{
		switch (api)
		{
#			if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2)
			case EGL_OPENGL_ES_API:
			{
				psTls->ui32API = IMGEGL_API_OPENGLES;

				psTls->lastError = EGL_SUCCESS;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindAPI);

				return EGL_TRUE;
			}
#			endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) */

#			if defined(SUPPORT_OPENGL)
			case EGL_OPENGL_API:
			{
				psTls->ui32API = IMGEGL_API_OPENGL;

				psTls->lastError = EGL_SUCCESS;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindAPI);

				return EGL_TRUE;
			}
#			endif /* defined(SUPPORT_OPENGL) */

#			if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX)
			case EGL_OPENVG_API:
			{
				psTls->ui32API = IMGEGL_API_OPENVG;

				psTls->lastError = EGL_SUCCESS;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindAPI);

				return EGL_TRUE;
			}
#			endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) */

			default:
			{
				PVR_DPF((PVR_DBG_WARNING, "IMGeglBindAPI: Invalid client API: %x", api));

				psTls->lastError = EGL_BAD_PARAMETER;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglBindAPI);

				return EGL_FALSE;
			}
		}
	}
	#endif /* defined(API_MODULES_RUNTIME_CHECKED) */
}


/***********************************************************************************
 Function Name      : eglQueryAPI
 Inputs             :
 Outputs            :
 Returns            :
 Description        :
************************************************************************************/
IMG_EXPORT EGLenum IMGeglQueryAPI(void)
{
	TLS psTls;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglQueryAPI"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_NONE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglQueryAPI);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryAPI);

		return EGL_NONE;
	}
#endif

	switch (psTls->ui32API)
	{
#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
		case IMGEGL_API_OPENGLES:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryAPI);

			return EGL_OPENGL_ES_API;
		}
#endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
		case IMGEGL_API_OPENGL:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryAPI);

			return EGL_OPENGL_API;
		}
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
		case IMGEGL_API_OPENVG:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryAPI);

			return EGL_OPENVG_API;
		}
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED) */
		default:
		{
			IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglQueryAPI);

			return EGL_NONE;
		}
	}
}


/***********************************************************************************
 Function Name      : eglWaitClient
 Inputs             :
 Outputs            :
 Returns            :
 Description        :
************************************************************************************/
IMG_EXPORT EGLBoolean IMGeglWaitClient(void)
{
	TLS psTls;
	KEGL_CONTEXT *psContext;
	KEGL_SURFACE *psSurface;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglWaitClient"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglWaitClient);

	psTls->lastError = EGL_SUCCESS;

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitClient);

		return EGL_FALSE;
	}
#endif

	psContext = psTls->apsCurrentContext[psTls->ui32API];

	if (psContext == EGL_NO_CONTEXT)
	{
		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitClient);

		return EGL_TRUE;
	}

	psSurface = psTls->apsCurrentDrawSurface[psTls->ui32API];

	if (psSurface == EGL_NO_SURFACE)
	{
		psTls->lastError = EGL_BAD_CURRENT_SURFACE;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitClient);

		return EGL_FALSE;
	}

	if (psContext->eContextType == IMGEGL_CONTEXT_OPENGLES1)
	{
#if defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED)
		/* Only needed for pixmap surface - other types will be flushed at readpixel/swapbuffer */
		if(psSurface->type == EGL_SURFACE_PIXMAP)
		{
			IMG_EGLERROR eError;

			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES1Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOGLES1.pfnGLESFlushBuffersGC(psContext->hClientContext,
																			&psSurface->sRenderSurface,
																			IMG_FALSE,
																			IMG_FALSE,
																			IMG_TRUE);

			if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitClient);

				return EGL_FALSE;
			}
		}
#endif /* defined(SUPPORT_OPENGLES1) || defined(API_MODULES_RUNTIME_CHECKED) */
	}
	else if (psContext->eContextType == IMGEGL_CONTEXT_OPENGLES2)
	{
#if defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
		/* Only needed for pixmap surface - other types will be flushed at readpixel/swapbuffer */
		if(psSurface->type == EGL_SURFACE_PIXMAP)
		{
			IMG_EGLERROR eError;

			PVR_ASSERT(psTls->psGlobalData->bHaveOGLES2Functions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOGLES2.pfnGLESFlushBuffersGC(psContext->hClientContext,
																			&psSurface->sRenderSurface,
																			IMG_FALSE,
																			IMG_FALSE,
																			IMG_TRUE);

			if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitClient);

				return EGL_FALSE;
			}
		}
#endif /* defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED) */
	}
	else if (psContext->eContextType == IMGEGL_CONTEXT_OPENGL)
	{
#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
		/* Only needed for pixmap surface - other types will be flushed at readpixel/swapbuffer */
		if(psSurface->type == EGL_SURFACE_PIXMAP)
		{
			IMG_EGLERROR eError;

			PVR_ASSERT(psTls->psGlobalData->bHaveOGLFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOGL.pfnGLFlushBuffersGC(psContext->hClientContext,
														IMG_FALSE,
														IMG_TRUE);

			if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitClient);

				return EGL_FALSE;
			}
		}
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */
	}
	else if (psContext->eContextType == IMGEGL_CONTEXT_OPENVG)
	{
#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
		/* Only needed for pixmap surface - other types will be flushed at readpixel/swapbuffer */
		if(psSurface->type == EGL_SURFACE_PIXMAP)
		{
			IMG_EGLERROR eError;

			PVR_ASSERT(psTls->psGlobalData->bHaveOVGFunctions)
			PVR_ASSERT(psTls->psGlobalData->spfnOVG.pfnOVGFlushBuffersGC)

			eError = psTls->psGlobalData->spfnOVG.pfnOVGFlushBuffersGC(psContext->hClientContext,
														IMG_FALSE,
														IMG_TRUE);

			if (eError == IMG_EGL_MEMORY_INVALID_ERROR)
			{
				psTls->lastError = EGL_CONTEXT_LOST;

				IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitClient);

				return EGL_FALSE;
			}
		}
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED) */
	}
	else
	{
		PVR_DPF((PVR_DBG_WARNING, "IMGeglWaitClient: Invalid client API"));
	}

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglWaitClient);

	return EGL_TRUE;
}


/***********************************************************************************
 Function Name      : eglReleaseThread
 Inputs             :
 Outputs            :
 Returns            :
 Description        :
************************************************************************************/
IMG_EXPORT EGLBoolean IMGeglReleaseThread(void)
{
	TLS psTls;
#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	SrvSysContext *psSysContext;
#endif

	PVR_DPF((PVR_DBG_CALLTRACE, "IMGeglReleaseThread"));

	psTls = TLS_Open(_TlsInit);

	if (psTls==IMG_NULL)
	{
		return EGL_FALSE;
	}

	IMGEGL_TIME_START(IMGEGL_TIMER_IMGeglReleaseThread);

#if defined(EGL_EXTENSION_IMG_EGL_HIBERNATION)
	psSysContext = &psTls->psGlobalData->sSysContext;
	if(psSysContext->bHibernated == IMG_TRUE)
	{
		psTls->lastError = EGL_HIBERNATED_IMG;

		IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseThread);

		return EGL_FALSE;
	}
#endif

#if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED)
	if (psTls->apsCurrentContext[IMGEGL_API_OPENGLES])
	{
		psTls->ui32API = IMGEGL_API_OPENGLES;

		if (!IMGeglMakeCurrent(psTls->apsCurrentContext[IMGEGL_API_OPENGLES]->eglDpy,
							   EGL_NO_SURFACE, EGL_NO_SURFACE,
							   EGL_NO_CONTEXT))
		{
			PVR_DPF((PVR_DBG_ERROR, "IMGeglReleaseThread: Make current of OpenGLES failed"));
		}
	}
#endif /* defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED)
	if (psTls->apsCurrentContext[IMGEGL_API_OPENGL])
	{
		psTls->ui32API = IMGEGL_API_OPENGL;

		if (!IMGeglMakeCurrent(psTls->apsCurrentContext[IMGEGL_API_OPENGL]->eglDpy,
							   EGL_NO_SURFACE, EGL_NO_SURFACE,
							   EGL_NO_CONTEXT))
		{
			PVR_DPF((PVR_DBG_ERROR, "IMGeglReleaseThread: Make current of OpenGL failed"));
		}
	}
#endif /* defined(SUPPORT_OPENGL) || defined(API_MODULES_RUNTIME_CHECKED) */

#if defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED)
	if (psTls->apsCurrentContext[IMGEGL_API_OPENVG])
	{
		psTls->ui32API = IMGEGL_API_OPENVG;

		if (!IMGeglMakeCurrent(psTls->apsCurrentContext[IMGEGL_API_OPENVG]->eglDpy,
							   EGL_NO_SURFACE, EGL_NO_SURFACE,
							   EGL_NO_CONTEXT))
		{
			PVR_DPF((PVR_DBG_ERROR, "IMGeglReleaseThread: Make current of OpenVG failed"));
		}
	}
#endif /* defined(SUPPORT_OPENVG) || defined(SUPPORT_OPENVGX) || defined(API_MODULES_RUNTIME_CHECKED) */

	/* Reset current rendering API to its value at thread initialisation */
#	if defined(API_MODULES_RUNTIME_CHECKED)
	{
		if(
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES1] ||
			psTls->psGlobalData->bApiModuleDetected[IMGEGL_CONTEXT_OPENGLES2]
		)
		{
			psTls->ui32API = IMGEGL_API_OPENGLES;
		}
		else
		{
			psTls->ui32API = IMGEGL_API_NONE;
		}
	}
#	else /* defined(API_MODULES_RUNTIME_CHECKED) */
	{
#		if defined(SUPPORT_OPENGLES1) || defined(SUPPORT_OPENGLES2)
		{
			psTls->ui32API = IMGEGL_API_OPENGLES;
		}
#		else
		{
			psTls->ui32API = IMGEGL_API_NONE;
		}
#		endif
	}
#	endif /* defined(API_MODULES_RUNTIME_CHECKED) */

	IMGEGL_TIME_STOP(IMGEGL_TIMER_IMGeglReleaseThread);

	TLS_Close(_TlsDeInit);

	return EGL_TRUE;
}




/******************************************************************************
 End of file (khronos_egl.c)
******************************************************************************/
